"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([[6342],{7754:(n,e,t)=>{t.d(e,{Z:()=>g});var i=t(2949),a=t(7294),o=t(4184),r=t.n(o),s=t(2695);var d=t(2215),p=t(9604),c=t(5893);function l(n){let{code:e,onChange:t}=n;const o=(0,a.useRef)(null),r=(0,a.useCallback)((n=>{o.current=n}),[]);(0,a.useEffect)((()=>{const n=()=>{null!==o.current&&o.current.layout({})};return window.addEventListener("resize",n),()=>{window.removeEventListener("resize",n)}}),[]);const{colorMode:s}=(0,i.I)();return(0,c.jsx)(p.ZP,{defaultLanguage:"javascript",value:e,defaultPath:"inmemory://model//src/index.ts",onChange:t,options:{lineNumbers:"off",padding:{top:24},minimap:{enabled:!1},fontSize:14,scrollBeyondLastLine:!1,scrollbar:{alwaysConsumeMouseWheel:!1}},onMount:r,theme:"dark"===s?"vs-dark":"light"})}const h=n=>{let{code:e,isPixiWebWorkerVersion:t,isPixiDevVersion:i,pixiVersion:o}=n;const r=(n=>(0,a.useMemo)((()=>({".babelrc":{code:JSON.stringify({presets:[["@babel/preset-env",{useBuiltIns:"entry",corejs:"3.29",targets:"last 2 chrome versions"}]]},null,2)},"src/styles.css":"body { margin: 0; overflow: hidden; }","src/index.js":n,"index.html":'\n<!DOCTYPE html>\n  <html>\n  <head>\n  <title>PixiJS Playground</title>\n  <meta charset="UTF-8" />\n  <link rel="stylesheet" href="src/styles.css">\n</head>\n<body>\n  <script src="src/index.js"><\/script>\n</body>\n</html>',"package.json":{code:JSON.stringify({scripts:{start:"parcel index.html --open",build:"parcel build index.html"}},null,2)}})),[n]))(e),{dependenciesKey:s,dependencies:d}=(n=>{let{isPixiWebWorkerVersion:e,isPixiDevVersion:t,pixiVersion:i}=n;return(0,a.useMemo)((()=>{const n=e?"@pixi/webworker":"pixi.js",a=n=>t?`${i}/${n}`:i,o=[n,"@pixi/graphics-extras","@pixi/math-extras"].reduce(((n,e)=>({...n,[e]:a(e)})),{});return{dependenciesKey:`${n}-${i}`,dependencies:o}}),[t,e,i])})({isPixiWebWorkerVersion:t,isPixiDevVersion:i,pixiVersion:o});return{files:r,key:`${s}-${e}`,customSetup:{entry:"index.html",dependencies:d,devDependencies:{"@babel/core":"^7.21.3","parcel-bundler":"^1.6.1"}}}},u={spWrapper:"spWrapper_XZV1",tpWrapper:"tpWrapper_GpS1",spLayout:"spLayout_lAOU",tutorial:"tutorial_bUbR",editorWrapper:"editorWrapper_YBAz",previewWrapper:"previewWrapper_AZey",showOutput:"showOutput_G2Cm",fullscreen:"fullscreen_QlZ5",example:"example_nyOC",sandpackLoadingOverlay:"sandpackLoadingOverlay_nYYO",loadingPulse:"loadingPulse_IxQv"};function m(n){let{mode:e,onCodeChanged:t}=n;const{code:i,updateCode:o}=(0,s.m4)(),{sandpack:d}=(0,s.X3)(),[p,h]=(0,a.useState)(!1),{activeFile:m,bundlerState:g}=d,x=(0,a.useCallback)((n=>{const e=n??"";o(e),t?.(e)}),[t,o]),f=(0,a.useCallback)((()=>{h((n=>!n))}),[]);return(0,c.jsxs)(s.sp,{className:r()(u[e],p&&u.showOutput),children:[(0,c.jsx)("div",{className:u.editorWrapper,children:(0,c.jsx)(l,{code:i,onChange:x},m)}),(0,c.jsxs)("div",{className:u.previewWrapper,children:[(0,c.jsx)(s.Gj,{showOpenInCodeSandbox:!0}),!g&&(0,c.jsx)("div",{className:u.sandpackLoadingOverlay})]}),(0,c.jsx)("button",{onClick:f,children:p?"Show Code":"Show Output"})]})}function g(n){let{code:e,onCodeChanged:t,isPixiWebWorkerVersion:o=!1,isPixiDevVersion:r=!1,pixiVersion:p=d.$,mode:l="example"}=n;const{colorMode:g}=(0,i.I)(),{key:x,files:f,customSetup:b}=h({code:e,isPixiDevVersion:r,isPixiWebWorkerVersion:o,pixiVersion:p});var w,I;return w="example",void 0===(I="example"===l)&&(I=!0),(0,a.useEffect)((()=>{const n=document.querySelector("main > .container");if(null!==n&&I)return n.classList.add(w),()=>{n.classList.remove(w)}}),[w,I]),(0,c.jsx)(s.oT,{template:"vanilla",theme:g,files:f,customSetup:b,options:{classes:{"sp-wrapper":"tutorial"===l?u.tpWrapper:u.spWrapper,"sp-layout":u.spLayout}},children:(0,c.jsx)(m,{mode:l,onCodeChanged:t})},x)}},2215:(n,e,t)=>{t.d(e,{$:()=>s,_:()=>d});var i=t(7294),a=t(1825);const o=a.map((n=>{let{versionLabel:e,version:t}=n;return{label:e,value:t}})),r=(n,e)=>t=>t[n]===e,s=a.find(r("latest",!0)).version,d=n=>{let{selectedVersionId:e,setURLState:t}=n;const s=(0,i.useCallback)((n=>t({pixiVersion:n},!0,!0)),[t]);return{selectedVersion:(0,i.useMemo)((()=>a.find(r("version",e))),[e]),handleVersionChanged:s,versionOptions:o}}},3276:(n,e,t)=>{t.r(e),t.d(e,{default:()=>F});var i=t(902),a=t(7754),o=t(7294),r=t(4184),s=t.n(r);const d="select_LFtK",p="label_iJQG",c="labelText_vfPa";var l=t(5893);const h=n=>n.map((n=>{let{value:e,label:t}=n;return(0,l.jsx)("option",{value:e,children:t},e)}));function u(n){let{className:e,label:t,labelClassName:i,selectedId:a,options:r,onValueChange:u,...m}=n;const g=(0,o.useCallback)((n=>{u(n.target.value)}),[u]),x=(n=>n.length>0&&Array.isArray(n[0].options))(r),f=(0,l.jsxs)("select",{className:s()(d,e),...m,value:a,onChange:g,children:[x&&(b=r,b.map((n=>{let{label:e,options:t}=n;return(0,l.jsx)("optgroup",{label:e,children:h(t)},e)}))),!x&&h(r)]});var b;return t?(0,l.jsxs)("label",{className:s()(p,i),children:[(0,l.jsx)("span",{className:c,children:t}),f]}):f}const m=JSON.parse('{"basic":["container","transparentBackground","tinting","cacheAsBitmap","particleContainer","blendModes","simplePlane"],"advanced":["slots","scratchCard","starWarp","mouseTrail","screenShot","collisionDetection","spinners"],"sprite":["basic","textureSwap","animatedSpriteExplosion","animatedSpriteJet","animatedSpriteAnimationSpeed","tilingSprite","video"],"text":["pixiText","bitmapText","fromFont","webFont"],"graphics":["simple","advanced","dynamic"],"events":["click","interactivity","dragging","customMouseIcon","customHitarea",{"name":"hitTestingWithSpatialHash","hide":true},"logger","nestedBoundaryWithProjection","pointerTracker","slider"],"masks":["graphics","sprite","filter"],"filtersBasic":["blur","colorMatrix","displacementMapCrawlies","displacementMapFlag"],"filtersAdvanced":["mouseBlending","custom","shaderToyFilterRenderTexture"],"meshAndShaders":["texturedMeshBasic","texturedMeshAdvanced","triangle","triangleColor","triangleTextured","uniforms","sharingGeometry","sharedShader","mergingGeometry","interleavingGeometry","instancedGeometry","shaderToyMesh","multiPassShaderGeneratedMesh"],"textures":["textureRotate","renderTextureBasic","renderTextureAdvanced","gradientBasic","gradientResource"],"assets":["promise","async","multiple","background","bundle"],"offscreenCanvas":["basic",{"name":"webWorker","hide":true,"usesWebWorkerLibrary":true}]}'),g={basic:{blendModes:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// create a new background sprite\nconst background = PIXI.Sprite.from('https://pixijs.com/assets/bg_rotate.jpg');\n\nbackground.width = app.screen.width;\nbackground.height = app.screen.height;\napp.stage.addChild(background);\n\n// create an array to store a reference to the dudes\nconst dudeArray = [];\n\nconst totaldudes = 20;\n\nfor (let i = 0; i < totaldudes; i++)\n{\n    // create a new Sprite that uses the image name that we just generated as its source\n    const dude = PIXI.Sprite.from('https://pixijs.com/assets/flowerTop.png');\n\n    dude.anchor.set(0.5);\n\n    // set a random scale for the dude\n    dude.scale.set(0.8 + Math.random() * 0.3);\n\n    // finally let's set the dude to be at a random position...\n    dude.x = Math.floor(Math.random() * app.screen.width);\n    dude.y = Math.floor(Math.random() * app.screen.height);\n\n    // The important bit of this example, this is how you change the default blend mode of the sprite\n    dude.blendMode = PIXI.BLEND_MODES.ADD;\n\n    // create some extra properties that will control movement\n    dude.direction = Math.random() * Math.PI * 2;\n\n    // this number will be used to modify the direction of the dude over time\n    dude.turningSpeed = Math.random() - 0.8;\n\n    // create a random speed for the dude between 0 - 2\n    dude.speed = 2 + Math.random() * 2;\n\n    // finally we push the dude into the dudeArray so it it can be easily accessed later\n    dudeArray.push(dude);\n\n    app.stage.addChild(dude);\n}\n\n// create a bounding box for the little dudes\nconst dudeBoundsPadding = 100;\n\nconst dudeBounds = new PIXI.Rectangle(\n    -dudeBoundsPadding,\n    -dudeBoundsPadding,\n    app.screen.width + dudeBoundsPadding * 2,\n    app.screen.height + dudeBoundsPadding * 2,\n);\n\napp.ticker.add(() =>\n{\n    // iterate through the dudes and update the positions\n    for (let i = 0; i < dudeArray.length; i++)\n    {\n        const dude = dudeArray[i];\n\n        dude.direction += dude.turningSpeed * 0.01;\n        dude.x += Math.sin(dude.direction) * dude.speed;\n        dude.y += Math.cos(dude.direction) * dude.speed;\n        dude.rotation = -dude.direction - Math.PI / 2;\n\n        // wrap the dudes by testing their bounds...\n        if (dude.x < dudeBounds.x)\n        {\n            dude.x += dudeBounds.width;\n        }\n        else if (dude.x > dudeBounds.x + dudeBounds.width)\n        {\n            dude.x -= dudeBounds.width;\n        }\n\n        if (dude.y < dudeBounds.y)\n        {\n            dude.y += dudeBounds.height;\n        }\n        else if (dude.y > dudeBounds.y + dudeBounds.height)\n        {\n            dude.y -= dudeBounds.height;\n        }\n    }\n});\n",cacheAsBitmap:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\napp.stop();\n\n// load resources\nPIXI.Assets.load('https://pixijs.com/assets/spritesheet/monsters.json')\n    .then(onAssetsLoaded);\n\n// holder to store aliens\nconst aliens = [];\nconst alienFrames = [\n    'eggHead.png',\n    'flowerTop.png',\n    'helmlok.png',\n    'skully.png',\n];\n\nlet count = 0;\n\n// create an empty container\nconst alienContainer = new PIXI.Container();\n\nalienContainer.x = 400;\nalienContainer.y = 300;\n\n// make the stage interactive\napp.stage.eventMode = 'static';\napp.stage.addChild(alienContainer);\n\nfunction onAssetsLoaded()\n{\n    // add a bunch of aliens with textures from image paths\n    for (let i = 0; i < 100; i++)\n    {\n        const frameName = alienFrames[i % 4];\n\n        // create an alien using the frame name..\n        const alien = PIXI.Sprite.from(frameName);\n\n        alien.tint = Math.random() * 0xFFFFFF;\n\n        alien.x = Math.random() * 800 - 400;\n        alien.y = Math.random() * 600 - 300;\n        alien.anchor.x = 0.5;\n        alien.anchor.y = 0.5;\n        aliens.push(alien);\n        alienContainer.addChild(alien);\n    }\n    app.start();\n}\n\n// Combines both mouse click + touch tap\napp.stage.on('pointertap', onClick);\n\nfunction onClick()\n{\n    alienContainer.cacheAsBitmap = !alienContainer.cacheAsBitmap;\n}\n\napp.ticker.add(() =>\n{\n    // let's rotate the aliens a little bit\n    for (let i = 0; i < 100; i++)\n    {\n        const alien = aliens[i];\n\n        alien.rotation += 0.1;\n    }\n\n    count += 0.01;\n\n    alienContainer.scale.x = Math.sin(count);\n    alienContainer.scale.y = Math.sin(count);\n    alienContainer.rotation += 0.01;\n});\n",container:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ background: '#1099bb', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nconst container = new PIXI.Container();\n\napp.stage.addChild(container);\n\n// Create a new texture\nconst texture = PIXI.Texture.from('https://pixijs.com/assets/bunny.png');\n\n// Create a 5x5 grid of bunnies\nfor (let i = 0; i < 25; i++)\n{\n    const bunny = new PIXI.Sprite(texture);\n\n    bunny.anchor.set(0.5);\n    bunny.x = (i % 5) * 40;\n    bunny.y = Math.floor(i / 5) * 40;\n    container.addChild(bunny);\n}\n\n// Move container to the center\ncontainer.x = app.screen.width / 2;\ncontainer.y = app.screen.height / 2;\n\n// Center bunny sprite in local container coordinates\ncontainer.pivot.x = container.width / 2;\ncontainer.pivot.y = container.height / 2;\n\n// Listen for animate update\napp.ticker.add((delta) =>\n{\n    // rotate the container!\n    // use delta to create frame-independent transform\n    container.rotation -= 0.01 * delta;\n});\n",particleContainer:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nconst sprites = new PIXI.ParticleContainer(10000, {\n    scale: true,\n    position: true,\n    rotation: true,\n    uvs: true,\n    alpha: true,\n});\n\napp.stage.addChild(sprites);\n\n// create an array to store all the sprites\nconst maggots = [];\n\nconst totalSprites = app.renderer instanceof PIXI.Renderer ? 10000 : 100;\n\nfor (let i = 0; i < totalSprites; i++)\n{\n    // create a new Sprite\n    const dude = PIXI.Sprite.from('https://pixijs.com/assets/maggot_tiny.png');\n\n    // set the anchor point so the texture is centerd on the sprite\n    dude.anchor.set(0.5);\n\n    // different maggots, different sizes\n    dude.scale.set(0.8 + Math.random() * 0.3);\n\n    // scatter them all\n    dude.x = Math.random() * app.screen.width;\n    dude.y = Math.random() * app.screen.height;\n\n    dude.tint = Math.random() * 0x808080;\n\n    // create a random direction in radians\n    dude.direction = Math.random() * Math.PI * 2;\n\n    // this number will be used to modify the direction of the sprite over time\n    dude.turningSpeed = Math.random() - 0.8;\n\n    // create a random speed between 0 - 2, and these maggots are slooww\n    dude.speed = (2 + Math.random() * 2) * 0.2;\n\n    dude.offset = Math.random() * 100;\n\n    // finally we push the dude into the maggots array so it it can be easily accessed later\n    maggots.push(dude);\n\n    sprites.addChild(dude);\n}\n\n// create a bounding box box for the little maggots\nconst dudeBoundsPadding = 100;\nconst dudeBounds = new PIXI.Rectangle(\n    -dudeBoundsPadding,\n    -dudeBoundsPadding,\n    app.screen.width + dudeBoundsPadding * 2,\n    app.screen.height + dudeBoundsPadding * 2,\n);\n\nlet tick = 0;\n\napp.ticker.add(() =>\n{\n    // iterate through the sprites and update their position\n    for (let i = 0; i < maggots.length; i++)\n    {\n        const dude = maggots[i];\n\n        dude.scale.y = 0.95 + Math.sin(tick + dude.offset) * 0.05;\n        dude.direction += dude.turningSpeed * 0.01;\n        dude.x += Math.sin(dude.direction) * (dude.speed * dude.scale.y);\n        dude.y += Math.cos(dude.direction) * (dude.speed * dude.scale.y);\n        dude.rotation = -dude.direction + Math.PI;\n\n        // wrap the maggots\n        if (dude.x < dudeBounds.x)\n        {\n            dude.x += dudeBounds.width;\n        }\n        else if (dude.x > dudeBounds.x + dudeBounds.width)\n        {\n            dude.x -= dudeBounds.width;\n        }\n\n        if (dude.y < dudeBounds.y)\n        {\n            dude.y += dudeBounds.height;\n        }\n        else if (dude.y > dudeBounds.y + dudeBounds.height)\n        {\n            dude.y -= dudeBounds.height;\n        }\n    }\n\n    // increment the ticker\n    tick += 0.1;\n});\n",simplePlane:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ background: '#1099bb', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nPIXI.Assets.load('https://pixijs.com/assets/bg_grass.jpg').then((texture) =>\n{\n    const plane = new PIXI.SimplePlane(texture, 10, 10);\n\n    plane.x = 100;\n    plane.y = 100;\n\n    app.stage.addChild(plane);\n\n    // Get the buffer for vertice positions.\n    const buffer = plane.geometry.getBuffer('aVertexPosition');\n\n    // Listen for animate update\n    let timer = 0;\n\n    app.ticker.add(() =>\n    {\n        // Randomize the vertice positions a bit to create movement.\n        for (let i = 0; i < buffer.data.length; i++)\n        {\n            buffer.data[i] += Math.sin((timer / 10) + i) * 0.5;\n        }\n        buffer.update();\n        timer++;\n    });\n});\n",tinting:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// holder to store the aliens\nconst aliens = [];\n\nconst totalDudes = 20;\n\nfor (let i = 0; i < totalDudes; i++)\n{\n    // create a new Sprite that uses the image name that we just generated as its source\n    const dude = PIXI.Sprite.from('https://pixijs.com/assets/eggHead.png');\n\n    // set the anchor point so the texture is centered on the sprite\n    dude.anchor.set(0.5);\n\n    // set a random scale for the dude - no point them all being the same size!\n    dude.scale.set(0.8 + Math.random() * 0.3);\n\n    // finally lets set the dude to be at a random position..\n    dude.x = Math.random() * app.screen.width;\n    dude.y = Math.random() * app.screen.height;\n\n    dude.tint = Math.random() * 0xFFFFFF;\n\n    // create some extra properties that will control movement :\n    // create a random direction in radians. This is a number between 0 and PI*2 which is the equivalent of 0 - 360 degrees\n    dude.direction = Math.random() * Math.PI * 2;\n\n    // this number will be used to modify the direction of the dude over time\n    dude.turningSpeed = Math.random() - 0.8;\n\n    // create a random speed for the dude between 2 - 4\n    dude.speed = 2 + Math.random() * 2;\n\n    // finally we push the dude into the aliens array so it it can be easily accessed later\n    aliens.push(dude);\n\n    app.stage.addChild(dude);\n}\n\n// create a bounding box for the little dudes\nconst dudeBoundsPadding = 100;\nconst dudeBounds = new PIXI.Rectangle(-dudeBoundsPadding,\n    -dudeBoundsPadding,\n    app.screen.width + dudeBoundsPadding * 2,\n    app.screen.height + dudeBoundsPadding * 2);\n\napp.ticker.add(() =>\n{\n    // iterate through the dudes and update their position\n    for (let i = 0; i < aliens.length; i++)\n    {\n        const dude = aliens[i];\n\n        dude.direction += dude.turningSpeed * 0.01;\n        dude.x += Math.sin(dude.direction) * dude.speed;\n        dude.y += Math.cos(dude.direction) * dude.speed;\n        dude.rotation = -dude.direction - Math.PI / 2;\n\n        // wrap the dudes by testing their bounds...\n        if (dude.x < dudeBounds.x)\n        {\n            dude.x += dudeBounds.width;\n        }\n        else if (dude.x > dudeBounds.x + dudeBounds.width)\n        {\n            dude.x -= dudeBounds.width;\n        }\n\n        if (dude.y < dudeBounds.y)\n        {\n            dude.y += dudeBounds.height;\n        }\n        else if (dude.y > dudeBounds.y + dudeBounds.height)\n        {\n            dude.y -= dudeBounds.height;\n        }\n    }\n});\n",transparentBackground:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ backgroundAlpha: 0, resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// create a new Sprite from an image path.\nconst bunny = PIXI.Sprite.from('https://pixijs.com/assets/bunny.png');\n\n// center the sprite's anchor point\nbunny.anchor.set(0.5);\n\n// move the sprite to the center of the screen\nbunny.x = app.screen.width / 2;\nbunny.y = app.screen.height / 2;\n\napp.stage.addChild(bunny);\n\napp.ticker.add(() =>\n{\n    // just for fun, let's rotate mr rabbit a little\n    bunny.rotation += 0.1;\n});\n"},sprite:{animatedSpriteAnimationSpeed:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ autoStart: false, resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nPIXI.Assets.load('https://pixijs.com/assets/spritesheet/0123456789.json').then((spritesheet) =>\n{\n    // create an array to store the textures\n    const textures = [];\n    let i;\n\n    for (i = 0; i < 10; i++)\n    {\n        const framekey = `0123456789 ${i}.ase`;\n        const texture = PIXI.Texture.from(framekey);\n        const time = spritesheet.data.frames[framekey].duration;\n\n        textures.push({ texture, time });\n    }\n\n    const scaling = 4;\n\n    // create a slow AnimatedSprite\n    const slow = new PIXI.AnimatedSprite(textures);\n\n    slow.anchor.set(0.5);\n    slow.scale.set(scaling);\n    slow.animationSpeed = 0.5;\n    slow.x = (app.screen.width - slow.width) / 2;\n    slow.y = app.screen.height / 2;\n    slow.play();\n    app.stage.addChild(slow);\n\n    // create a fast AnimatedSprite\n    const fast = new PIXI.AnimatedSprite(textures);\n\n    fast.anchor.set(0.5);\n    fast.scale.set(scaling);\n    fast.x = (app.screen.width + fast.width) / 2;\n    fast.y = app.screen.height / 2;\n    fast.play();\n    app.stage.addChild(fast);\n\n    // start animating\n    app.start();\n});\n",animatedSpriteExplosion:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ autoStart: false, resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nPIXI.Assets.load('https://pixijs.com/assets/spritesheet/mc.json').then(() =>\n{\n    // create an array to store the textures\n    const explosionTextures = [];\n    let i;\n\n    for (i = 0; i < 26; i++)\n    {\n        const texture = PIXI.Texture.from(`Explosion_Sequence_A ${i + 1}.png`);\n\n        explosionTextures.push(texture);\n    }\n\n    for (i = 0; i < 50; i++)\n    {\n        // create an explosion AnimatedSprite\n        const explosion = new PIXI.AnimatedSprite(explosionTextures);\n\n        explosion.x = Math.random() * app.screen.width;\n        explosion.y = Math.random() * app.screen.height;\n        explosion.anchor.set(0.5);\n        explosion.rotation = Math.random() * Math.PI;\n        explosion.scale.set(0.75 + Math.random() * 0.5);\n        explosion.gotoAndPlay(Math.random() * 26 | 0);\n        app.stage.addChild(explosion);\n    }\n\n    // start animating\n    app.start();\n});\n",animatedSpriteJet:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ background: '#1099bb', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nPIXI.Assets.load('https://pixijs.com/assets/spritesheet/fighter.json').then(() =>\n{\n    // create an array of textures from an image path\n    const frames = [];\n\n    for (let i = 0; i < 30; i++)\n    {\n        const val = i < 10 ? `0${i}` : i;\n\n        // magically works since the spritesheet was loaded with the pixi loader\n        frames.push(PIXI.Texture.from(`rollSequence00${val}.png`));\n    }\n\n    // create an AnimatedSprite (brings back memories from the days of Flash, right ?)\n    const anim = new PIXI.AnimatedSprite(frames);\n\n    /*\n     * An AnimatedSprite inherits all the properties of a PIXI sprite\n     * so you can change its position, its anchor, mask it, etc\n     */\n    anim.x = app.screen.width / 2;\n    anim.y = app.screen.height / 2;\n    anim.anchor.set(0.5);\n    anim.animationSpeed = 0.5;\n    anim.play();\n\n    app.stage.addChild(anim);\n\n    // Animate the rotation\n    app.ticker.add(() =>\n    {\n        anim.rotation += 0.01;\n    });\n});\n",basic:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ background: '#1099bb', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// create a new Sprite from an image path\nconst bunny = PIXI.Sprite.from('https://pixijs.com/assets/bunny.png');\n\n// center the sprite's anchor point\nbunny.anchor.set(0.5);\n\n// move the sprite to the center of the screen\nbunny.x = app.screen.width / 2;\nbunny.y = app.screen.height / 2;\n\napp.stage.addChild(bunny);\n\n// Listen for animate update\napp.ticker.add((delta) =>\n{\n    // just for fun, let's rotate mr rabbit a little\n    // delta is 1 if running at 100% performance\n    // creates frame-independent transformation\n    bunny.rotation += 0.1 * delta;\n});\n",textureSwap:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ background: '#1099bb', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nlet isFlower = true;\n\nconst texture = PIXI.Texture.from('https://pixijs.com/assets/flowerTop.png');\nconst secondTexture = PIXI.Texture.from('https://pixijs.com/assets/eggHead.png');\n\n// create a new Sprite using the texture\nconst character = new PIXI.Sprite(texture);\n\n// center the sprites anchor point\ncharacter.anchor.set(0.5);\n\n// move the sprite to the center of the screen\ncharacter.x = app.screen.width / 2;\ncharacter.y = app.screen.height / 2;\n\napp.stage.addChild(character);\n\n// make the sprite interactive\ncharacter.eventMode = 'static';\ncharacter.cursor = 'pointer';\n\ncharacter.on('pointertap', () =>\n{\n    isFlower = !isFlower;\n    // Dynamically swap the texture\n    character.texture = isFlower ? texture : secondTexture;\n});\n\napp.ticker.add(() =>\n{\n    character.rotation += 0.02;\n});\n",tilingSprite:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// create a texture from an image path\nconst texture = PIXI.Texture.from('https://pixijs.com/assets/p2.jpeg');\n\n/* create a tiling sprite ...\n * requires a texture, a width and a height\n * in WebGL the image size should preferably be a power of two\n */\nconst tilingSprite = new PIXI.TilingSprite(\n    texture,\n    app.screen.width,\n    app.screen.height,\n);\n\napp.stage.addChild(tilingSprite);\n\nlet count = 0;\n\napp.ticker.add(() =>\n{\n    count += 0.005;\n\n    tilingSprite.tileScale.x = 2 + Math.sin(count);\n    tilingSprite.tileScale.y = 2 + Math.cos(count);\n\n    tilingSprite.tilePosition.x += 1;\n    tilingSprite.tilePosition.y += 1;\n});\n",video:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ backgroundAlpha: 0, resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// Create play button that can be used to trigger the video\nconst button = new PIXI.Graphics()\n    .beginFill(0x0, 0.5)\n    .drawRoundedRect(0, 0, 100, 100, 10)\n    .endFill()\n    .beginFill(0xffffff)\n    .moveTo(36, 30)\n    .lineTo(36, 70)\n    .lineTo(70, 50);\n\n// Position the button\nbutton.x = (app.screen.width - button.width) / 2;\nbutton.y = (app.screen.height - button.height) / 2;\n\n// Enable interactivity on the button\nbutton.eventMode = 'static';\nbutton.cursor = 'pointer';\n\n// Add to the stage\napp.stage.addChild(button);\n\n// Listen for a click/tap event to start playing the video\n// this is useful for some mobile platforms. For example:\n// ios9 and under cannot render videos in PIXI without a\n// polyfill - https://github.com/bfred-it/iphone-inline-video\n// ios10 and above require a click/tap event to render videos\n// that contain audio in PIXI. Videos with no audio track do\n// not have this requirement\nbutton.on('pointertap', onPlayVideo);\n\nfunction onPlayVideo()\n{\n    // Don't need the button anymore\n    button.destroy();\n\n    // create a video texture from a path\n    const texture = PIXI.Texture.from('https://pixijs.com/assets/video.mp4');\n\n    // create a new Sprite using the video texture (yes it's that easy)\n    const videoSprite = new PIXI.Sprite(texture);\n\n    // Stetch the fullscreen\n    videoSprite.width = app.screen.width;\n    videoSprite.height = app.screen.height;\n\n    app.stage.addChild(videoSprite);\n}\n"},text:{bitmapText:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ background: '#1099bb', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nPIXI.Assets.load('https://pixijs.com/assets/bitmap-font/desyrel.xml').then(() =>\n{\n    const bitmapFontText = new PIXI.BitmapText(\n        'bitmap fonts are supported!\\nWoo yay!', {\n            fontName: 'Desyrel',\n            fontSize: 55,\n            align: 'left',\n        },\n    );\n\n    bitmapFontText.x = 50;\n    bitmapFontText.y = 200;\n\n    app.stage.addChild(bitmapFontText);\n});\n",fromFont:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ background: '#1099bb', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// Load from any font file!\nPIXI.Assets.addBundle('fonts', {\n    ChaChicle: 'https://pixijs.com/assets/webfont-loader/ChaChicle.ttf',\n    Lineal: 'https://pixijs.com/assets/webfont-loader/Lineal.otf',\n    'Dotrice Regular': 'https://pixijs.com/assets/webfont-loader/Dotrice-Regular.woff',\n    Crosterian: 'https://pixijs.com/assets/webfont-loader/Crosterian.woff2',\n});\nPIXI.Assets.loadBundle('fonts').then(() =>\n{\n    const text1 = new PIXI.Text('ChaChicle.ttf', new PIXI.TextStyle({ fontFamily: 'ChaChicle', fontSize: 50 }));\n    const text2 = new PIXI.Text('Lineal.otf', new PIXI.TextStyle({ fontFamily: 'Lineal', fontSize: 50 }));\n    const text3 = new PIXI.Text('Dotrice Regular.woff', new PIXI.TextStyle({ fontFamily: 'Dotrice Regular', fontSize: 50 }));\n    const text4 = new PIXI.Text('Crosterian.woff2', new PIXI.TextStyle({ fontFamily: 'Crosterian', fontSize: 50 }));\n\n    text2.y = 150;\n    text3.y = 300;\n    text4.y = 450;\n\n    app.stage.addChild(text1);\n    app.stage.addChild(text2);\n    app.stage.addChild(text3);\n    app.stage.addChild(text4);\n});\n",pixiText:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ background: '#1099bb', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nconst basicText = new PIXI.Text('Basic text in pixi');\n\nbasicText.x = 50;\nbasicText.y = 100;\n\napp.stage.addChild(basicText);\n\nconst style = new PIXI.TextStyle({\n    fontFamily: 'Arial',\n    fontSize: 36,\n    fontStyle: 'italic',\n    fontWeight: 'bold',\n    fill: ['#ffffff', '#00ff99'], // gradient\n    stroke: '#4a1850',\n    strokeThickness: 5,\n    dropShadow: true,\n    dropShadowColor: '#000000',\n    dropShadowBlur: 4,\n    dropShadowAngle: Math.PI / 6,\n    dropShadowDistance: 6,\n    wordWrap: true,\n    wordWrapWidth: 440,\n    lineJoin: 'round',\n});\n\nconst richText = new PIXI.Text('Rich text with a lot of options and across multiple lines', style);\n\nrichText.x = 50;\nrichText.y = 220;\n\napp.stage.addChild(richText);\n\nconst skewStyle = new PIXI.TextStyle({\n    fontFamily: 'Arial',\n    dropShadow: true,\n    dropShadowAlpha: 0.8,\n    dropShadowAngle: 2.1,\n    dropShadowBlur: 4,\n    dropShadowColor: '0x111111',\n    dropShadowDistance: 10,\n    fill: ['#ffffff'],\n    stroke: '#004620',\n    fontSize: 60,\n    fontWeight: 'lighter',\n    lineJoin: 'round',\n    strokeThickness: 12,\n});\n\nconst skewText = new PIXI.Text('SKEW IS COOL', skewStyle);\n\nskewText.skew.set(0.65, -0.3);\nskewText.anchor.set(0.5, 0.5);\nskewText.x = 300;\nskewText.y = 480;\n\napp.stage.addChild(skewText);\n",webFont:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ background: '#1099bb', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// Load them google fonts before starting...\nwindow.WebFontConfig = {\n    google: {\n        families: ['Snippet'],\n    },\n    active()\n    {\n        init();\n    },\n};\n\n/* eslint-disable */\n// include the web-font loader script\n(function() {\n    const wf = document.createElement('script');\n    wf.src = `${document.location.protocol === 'https:' ? 'https' : 'http'\n    }://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js`;\n    wf.type = 'text/javascript';\n    wf.async = 'true';\n    const s = document.getElementsByTagName('script')[0];\n    s.parentNode.insertBefore(wf, s);\n}());\n/* eslint-enabled */\n\nfunction init() {\n    // create some white text using the Snippet webfont\n    const textSample = new PIXI.Text(\n        'PixiJS text using the\\ncustom \"Snippet\" Webfont', {\n            fontFamily: 'Snippet',\n            fontSize: 50,\n            fill: 'white',\n            align: 'left',\n        }\n    );\n    textSample.position.set(50, 200);\n    app.stage.addChild(textSample);\n}"},graphics:{advanced:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ antialias: true, resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nconst sprite = PIXI.Sprite.from('https://pixijs.com/assets/bg_rotate.jpg');\n\n// // BEZIER CURVE ////\n// information: https://en.wikipedia.org/wiki/B\xe9zier_curve\n\nconst realPath = new PIXI.Graphics();\n\nrealPath.lineStyle(2, 0xFFFFFF, 1);\nrealPath.moveTo(0, 0);\nrealPath.lineTo(100, 200);\nrealPath.lineTo(200, 200);\nrealPath.lineTo(240, 100);\n\nrealPath.position.x = 50;\nrealPath.position.y = 50;\n\napp.stage.addChild(realPath);\n\nconst bezier = new PIXI.Graphics();\n\nbezier.lineStyle(5, 0xAA0000, 1);\nbezier.bezierCurveTo(100, 200, 200, 200, 240, 100);\n\nbezier.position.x = 50;\nbezier.position.y = 50;\n\napp.stage.addChild(bezier);\n\n// // BEZIER CURVE 2 ////\nconst realPath2 = new PIXI.Graphics();\n\nrealPath2.lineStyle(2, 0xFFFFFF, 1);\nrealPath2.moveTo(0, 0);\nrealPath2.lineTo(0, -100);\nrealPath2.lineTo(150, 150);\nrealPath2.lineTo(240, 100);\n\nrealPath2.position.x = 320;\nrealPath2.position.y = 150;\n\napp.stage.addChild(realPath2);\n\nconst bezier2 = new PIXI.Graphics();\n\nbezier2.lineTextureStyle({ width: 10, texture: sprite.texture });\nbezier2.bezierCurveTo(0, -100, 150, 150, 240, 100);\n\nbezier2.position.x = 320;\nbezier2.position.y = 150;\n\napp.stage.addChild(bezier2);\n\n// // ARC ////\nconst arc = new PIXI.Graphics();\n\narc.lineStyle(5, 0xAA00BB, 1);\narc.arc(600, 100, 50, Math.PI, 2 * Math.PI);\n\napp.stage.addChild(arc);\n\n// // ARC 2 ////\nconst arc2 = new PIXI.Graphics();\n\narc2.lineStyle(6, 0x3333DD, 1);\narc2.arc(650, 270, 60, 2 * Math.PI, 3 * Math.PI / 2);\n\napp.stage.addChild(arc2);\n\n// // ARC 3 ////\nconst arc3 = new PIXI.Graphics();\n\narc3.lineTextureStyle({ width: 20, texture: sprite.texture });\narc3.arc(650, 420, 60, 2 * Math.PI, 2.5 * Math.PI / 2);\n\napp.stage.addChild(arc3);\n\n// / Hole ////\nconst rectAndHole = new PIXI.Graphics();\n\nrectAndHole.beginFill(0x00FF00);\nrectAndHole.drawRect(350, 350, 150, 150);\nrectAndHole.beginHole();\nrectAndHole.drawCircle(375, 375, 25);\nrectAndHole.drawCircle(425, 425, 25);\nrectAndHole.drawCircle(475, 475, 25);\nrectAndHole.endHole();\nrectAndHole.endFill();\n\napp.stage.addChild(rectAndHole);\n\n// // Line Texture Style ////\nconst beatifulRect = new PIXI.Graphics();\n\nbeatifulRect.lineTextureStyle({ width: 20, texture: sprite.texture });\nbeatifulRect.beginFill(0xFF0000);\nbeatifulRect.drawRect(80, 350, 150, 150);\nbeatifulRect.endFill();\n\napp.stage.addChild(beatifulRect);\n",dynamic:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ antialias: true, resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\napp.stage.eventMode = 'static';\napp.stage.hitArea = app.screen;\n\nconst graphics = new PIXI.Graphics();\n\n// set a fill and line style\ngraphics.beginFill(0xFF3300);\ngraphics.lineStyle(10, 0xffd900, 1);\n\n// draw a shape\ngraphics.moveTo(50, 50);\ngraphics.lineTo(250, 50);\ngraphics.lineTo(100, 100);\ngraphics.lineTo(250, 220);\ngraphics.lineTo(50, 220);\ngraphics.lineTo(50, 50);\ngraphics.closePath();\ngraphics.endFill();\n\n// set a fill and line style again\ngraphics.lineStyle(10, 0xFF0000, 0.8);\ngraphics.beginFill(0xFF700B, 1);\n\n// draw a second shape\ngraphics.moveTo(210, 300);\ngraphics.lineTo(450, 320);\ngraphics.lineTo(570, 350);\ngraphics.quadraticCurveTo(600, 0, 480, 100);\ngraphics.lineTo(330, 120);\ngraphics.lineTo(410, 200);\ngraphics.lineTo(210, 300);\ngraphics.closePath();\ngraphics.endFill();\n\n// draw a rectangle\ngraphics.lineStyle(2, 0x0000FF, 1);\ngraphics.drawRect(50, 250, 100, 100);\n\n// draw a circle\ngraphics.lineStyle(0);\ngraphics.beginFill(0xFFFF0B, 0.5);\ngraphics.drawCircle(470, 200, 100);\ngraphics.endFill();\n\ngraphics.lineStyle(20, 0x33FF00);\ngraphics.moveTo(30, 30);\ngraphics.lineTo(600, 300);\n\napp.stage.addChild(graphics);\n\n// let's create a moving shape\nconst thing = new PIXI.Graphics();\n\napp.stage.addChild(thing);\nthing.x = 800 / 2;\nthing.y = 600 / 2;\n\nlet count = 0;\n\n// Just click on the stage to draw random lines\nwindow.app = app;\napp.stage.on('pointerdown', () =>\n{\n    graphics.lineStyle(Math.random() * 30, Math.random() * 0xFFFFFF, 1);\n    graphics.moveTo(Math.random() * 800, Math.random() * 600);\n    graphics.bezierCurveTo(\n        Math.random() * 800, Math.random() * 600,\n        Math.random() * 800, Math.random() * 600,\n        Math.random() * 800, Math.random() * 600,\n    );\n});\n\napp.ticker.add(() =>\n{\n    count += 0.1;\n\n    thing.clear();\n    thing.lineStyle(10, 0xff0000, 1);\n    thing.beginFill(0xffFF00, 0.5);\n\n    thing.moveTo(-120 + Math.sin(count) * 20, -100 + Math.cos(count) * 20);\n    thing.lineTo(120 + Math.cos(count) * 20, -100 + Math.sin(count) * 20);\n    thing.lineTo(120 + Math.sin(count) * 20, 100 + Math.cos(count) * 20);\n    thing.lineTo(-120 + Math.cos(count) * 20, 100 + Math.sin(count) * 20);\n    thing.lineTo(-120 + Math.sin(count) * 20, -100 + Math.cos(count) * 20);\n    thing.closePath();\n\n    thing.rotation = count * 0.1;\n});\n",simple:"import * as PIXI from 'pixi.js';\nimport '@pixi/graphics-extras';\n\nconst app = new PIXI.Application({ antialias: true, resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nconst graphics = new PIXI.Graphics();\n\n// Rectangle\ngraphics.beginFill(0xDE3249);\ngraphics.drawRect(50, 50, 100, 100);\ngraphics.endFill();\n\n// Rectangle + line style 1\ngraphics.lineStyle(2, 0xFEEB77, 1);\ngraphics.beginFill(0x650A5A);\ngraphics.drawRect(200, 50, 100, 100);\ngraphics.endFill();\n\n// Rectangle + line style 2\ngraphics.lineStyle(10, 0xFFBD01, 1);\ngraphics.beginFill(0xC34288);\ngraphics.drawRect(350, 50, 100, 100);\ngraphics.endFill();\n\n// Rectangle 2\ngraphics.lineStyle(2, 0xFFFFFF, 1);\ngraphics.beginFill(0xAA4F08);\ngraphics.drawRect(530, 50, 140, 100);\ngraphics.endFill();\n\n// Circle\ngraphics.lineStyle(0); // draw a circle, set the lineStyle to zero so the circle doesn't have an outline\ngraphics.beginFill(0xDE3249, 1);\ngraphics.drawCircle(100, 250, 50);\ngraphics.endFill();\n\n// Circle + line style 1\ngraphics.lineStyle(2, 0xFEEB77, 1);\ngraphics.beginFill(0x650A5A, 1);\ngraphics.drawCircle(250, 250, 50);\ngraphics.endFill();\n\n// Circle + line style 2\ngraphics.lineStyle(10, 0xFFBD01, 1);\ngraphics.beginFill(0xC34288, 1);\ngraphics.drawCircle(400, 250, 50);\ngraphics.endFill();\n\n// Ellipse + line style 2\ngraphics.lineStyle(2, 0xFFFFFF, 1);\ngraphics.beginFill(0xAA4F08, 1);\ngraphics.drawEllipse(600, 250, 80, 50);\ngraphics.endFill();\n\n// draw a shape\ngraphics.beginFill(0xFF3300);\ngraphics.lineStyle(4, 0xffd900, 1);\ngraphics.moveTo(50, 350);\ngraphics.lineTo(250, 350);\ngraphics.lineTo(100, 400);\ngraphics.lineTo(50, 350);\ngraphics.closePath();\ngraphics.endFill();\n\n// draw a rounded rectangle\ngraphics.lineStyle(2, 0xFF00FF, 1);\ngraphics.beginFill(0x650A5A, 0.25);\ngraphics.drawRoundedRect(50, 440, 100, 100, 16);\ngraphics.endFill();\n\n// draw star\ngraphics.lineStyle(2, 0xFFFFFF);\ngraphics.beginFill(0x35CC5A, 1);\ngraphics.drawStar(360, 370, 5, 50);\ngraphics.endFill();\n\n// draw star 2\ngraphics.lineStyle(2, 0xFFFFFF);\ngraphics.beginFill(0xFFCC5A, 1);\ngraphics.drawStar(280, 510, 7, 50);\ngraphics.endFill();\n\n// draw star 3\ngraphics.lineStyle(4, 0xFFFFFF);\ngraphics.beginFill(0x55335A, 1);\ngraphics.drawStar(470, 450, 4, 50);\ngraphics.endFill();\n\n// draw polygon\nconst path = [600, 370, 700, 460, 780, 420, 730, 570, 590, 520];\n\ngraphics.lineStyle(0);\ngraphics.beginFill(0x3500FA, 1);\ngraphics.drawPolygon(path);\ngraphics.endFill();\n\napp.stage.addChild(graphics);\n"},events:{click:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ background: '#1099bb', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// Scale mode for all textures, will retain pixelation\nPIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;\n\nconst sprite = PIXI.Sprite.from('https://pixijs.com/assets/bunny.png');\n\n// Set the initial position\nsprite.anchor.set(0.5);\nsprite.x = app.screen.width / 2;\nsprite.y = app.screen.height / 2;\n\n// Opt-in to interactivity\nsprite.eventMode = 'static';\n\n// Shows hand cursor\nsprite.cursor = 'pointer';\n\n// Pointers normalize touch and mouse (good for mobile and desktop)\nsprite.on('pointerdown', onClick);\n\n// Alternatively, use the mouse & touch events:\n// sprite.on('click', onClick); // mouse-only\n// sprite.on('tap', onClick); // touch-only\n\napp.stage.addChild(sprite);\n\nfunction onClick()\n{\n    sprite.scale.x *= 1.25;\n    sprite.scale.y *= 1.25;\n}\n",customHitarea:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application(800, 600, { background: '#1099bb' });\n\ndocument.body.appendChild(app.view);\n\nconst yellowStar = PIXI.Texture.from('https://pixijs.com/assets/yellowstar.png');\n\n// Standard Sprite Button\nconst starButton1 = new PIXI.Sprite(yellowStar);\n\nstarButton1.position.set(50, 200);\nstarButton1.cursor = 'pointer';\nstarButton1.eventMode = 'static';\n\nstarButton1\n    .on('pointerdown', onClick, starButton1)\n    .on('pointerover', onPointerOver, starButton1)\n    .on('pointerout', onPointerOut, starButton1);\n\n// Custom Hitarea Button\nconst starButton2 = new PIXI.Sprite(yellowStar);\n\nstarButton2.position.set(250, 200);\n\n// Create a hitarea that matches the sprite, which will be used for point\n// intersection\nstarButton2.hitArea = new PIXI.Polygon([\n    80, 0,\n    100, 50,\n    160, 55,\n    115, 95,\n    130, 150,\n    80, 120,\n    30, 150,\n    45, 95,\n    0, 55,\n    60, 50,\n]);\nstarButton2.cursor = 'pointer';\nstarButton2.eventMode = 'static';\n\nstarButton2\n    .on('pointerdown', onClick, starButton2)\n    .on('pointerover', onPointerOver, starButton2)\n    .on('pointerout', onPointerOut, starButton2);\n\n// With Mask, No Hit Area\nconst starButton3 = new PIXI.Sprite(yellowStar);\n\nstarButton3.position.set(450, 200);\nstarButton3.cursor = 'pointer';\nstarButton3.eventMode = 'static';\n\nconst squareMask = new PIXI.Graphics()\n    .beginFill(0xFFFFFF)\n    .drawRect(starButton3.x, starButton3.y, 75, 200)\n    .endFill();\n\nstarButton3.mask = squareMask;\n\nstarButton3\n    .on('pointerdown', onClick, starButton3)\n    .on('pointerover', onPointerOver, starButton3)\n    .on('pointerout', onPointerOut, starButton3);\n\n// With a Mask and Hit Area\n// Hitareas ignore masks. You can still click on a button made in this way,\n// even from areas covered by a mask\nconst starButton4 = new PIXI.Sprite(yellowStar);\n\nstarButton4.position.set(600, 200);\n\nconst squareMask2 = new PIXI.Graphics()\n    .beginFill(0xFFFFFF)\n    .drawRect(starButton4.x, starButton4.y, 75, 200)\n    .endFill();\n\nstarButton4.mask = squareMask2;\n\n// Again, hitarea for intersection checks\nstarButton4.hitArea = new PIXI.Polygon([\n    80, 0,\n    100, 50,\n    160, 55,\n    115, 95,\n    130, 150,\n    80, 120,\n    30, 150,\n    45, 95,\n    0, 55,\n    60, 50,\n]);\nstarButton4.cursor = 'pointer';\nstarButton4.eventMode = 'static';\n\nstarButton4\n    .on('pointerdown', onClick, starButton4)\n    .on('pointerover', onPointerOver, starButton4)\n    .on('pointerout', onPointerOut, starButton4);\n\nconst style = new PIXI.TextStyle({ fill: '#ffffff' });\n\nconst text1 = new PIXI.Text('Standard', style);\n\ntext1.x = starButton1.x + 25;\ntext1.y = starButton1.y + 170;\n\nconst text2 = new PIXI.Text('Hit Area', style);\n\ntext2.x = starButton2.x + 35;\ntext2.y = starButton2.y + 170;\n\nconst text3 = new PIXI.Text('Mask', style);\n\ntext3.x = starButton3.x + 10;\ntext3.y = starButton3.y + 170;\n\nconst text4 = new PIXI.Text('Mask + Hit Area', style);\n\ntext4.x = starButton4.x - 10;\ntext4.y = starButton4.y + 170;\n\n// Add to stage\napp.stage.addChild(\n    starButton2,\n    starButton1,\n    starButton3,\n    starButton4,\n    squareMask,\n    squareMask2,\n    text1,\n    text2,\n    text3,\n    text4,\n);\n\nfunction onClick()\n{\n    this.tint = 0x333333;\n}\n\nfunction onPointerOver()\n{\n    this.tint = 0x666666;\n}\n\nfunction onPointerOut()\n{\n    this.tint = 0xFFFFFF;\n}\n",customMouseIcon:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ background: '#1099bb', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// Css style for icons\nconst defaultIcon = 'url(\\'https://pixijs.com/assets/bunny.png\\'),auto';\nconst hoverIcon = 'url(\\'https://pixijs.com/assets/bunny_saturated.png\\'),auto';\n\n// Add custom cursor styles\napp.renderer.events.cursorStyles.default = defaultIcon;\napp.renderer.events.cursorStyles.hover = hoverIcon;\n\n// create a background...\nconst background = PIXI.Sprite.from('https://pixijs.com/assets/bg_button.jpg');\n\nbackground.width = app.screen.width;\nbackground.height = app.screen.height;\n// add background to stage...\napp.stage.addChild(background);\n\n// create some textures from an image path\nconst textureButton = PIXI.Texture.from('https://pixijs.com/assets/button.png');\nconst textureButtonDown = PIXI.Texture.from('https://pixijs.com/assets/button_down.png');\nconst textureButtonOver = PIXI.Texture.from('https://pixijs.com/assets/button_over.png');\n\nconst buttons = [];\n\nconst buttonPositions = [\n    175, 75,\n    655, 75,\n    410, 325,\n    150, 465,\n    685, 445,\n];\n\nfor (let i = 0; i < 5; i++)\n{\n    const button = new PIXI.Sprite(textureButton);\n\n    button.cursor = 'hover';\n\n    button.anchor.set(0.5);\n    button.x = buttonPositions[i * 2];\n    button.y = buttonPositions[i * 2 + 1];\n\n    // make the button interactive...\n    button.eventMode = 'static';\n\n    button\n        .on('pointerdown', onButtonDown)\n        .on('pointerup', onButtonUp)\n        .on('pointerupoutside', onButtonUp)\n        .on('pointerover', onButtonOver)\n        .on('pointerout', onButtonOut);\n\n    // add it to the stage\n    app.stage.addChild(button);\n\n    // add button to array\n    buttons.push(button);\n}\n\n// set some silly values...\nbuttons[0].scale.set(1.2);\nbuttons[2].rotation = Math.PI / 10;\nbuttons[3].scale.set(0.8);\nbuttons[4].scale.set(0.8, 1.2);\nbuttons[4].rotation = Math.PI;\n\nfunction onButtonDown()\n{\n    this.isdown = true;\n    this.texture = textureButtonDown;\n    this.alpha = 1;\n}\n\nfunction onButtonUp()\n{\n    this.isdown = false;\n    if (this.isOver)\n    {\n        this.texture = textureButtonOver;\n    }\n    else\n    {\n        this.texture = textureButton;\n    }\n}\n\nfunction onButtonOver()\n{\n    this.isOver = true;\n    if (this.isdown)\n    {\n        return;\n    }\n    this.texture = textureButtonOver;\n}\n\nfunction onButtonOut()\n{\n    this.isOver = false;\n    if (this.isdown)\n    {\n        return;\n    }\n    this.texture = textureButton;\n}\n",dragging:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ background: '#1099bb', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// create a texture from an image path\nconst texture = PIXI.Texture.from('https://pixijs.com/assets/bunny.png');\n\n// Scale mode for pixelation\ntexture.baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;\n\nfor (let i = 0; i < 10; i++)\n{\n    createBunny(\n        Math.floor(Math.random() * app.screen.width),\n        Math.floor(Math.random() * app.screen.height),\n    );\n}\n\nfunction createBunny(x, y)\n{\n    // create our little bunny friend..\n    const bunny = new PIXI.Sprite(texture);\n\n    // enable the bunny to be interactive... this will allow it to respond to mouse and touch events\n    bunny.eventMode = 'static';\n\n    // this button mode will mean the hand cursor appears when you roll over the bunny with your mouse\n    bunny.cursor = 'pointer';\n\n    // center the bunny's anchor point\n    bunny.anchor.set(0.5);\n\n    // make it a bit bigger, so it's easier to grab\n    bunny.scale.set(3);\n\n    // setup events for mouse + touch using\n    // the pointer events\n    bunny.on('pointerdown', onDragStart, bunny);\n\n    // move the sprite to its designated position\n    bunny.x = x;\n    bunny.y = y;\n\n    // add it to the stage\n    app.stage.addChild(bunny);\n}\n\nlet dragTarget = null;\n\napp.stage.eventMode = 'static';\napp.stage.hitArea = app.screen;\napp.stage.on('pointerup', onDragEnd);\napp.stage.on('pointerupoutside', onDragEnd);\n\nfunction onDragMove(event)\n{\n    if (dragTarget)\n    {\n        dragTarget.parent.toLocal(event.global, null, dragTarget.position);\n    }\n}\n\nfunction onDragStart()\n{\n    // store a reference to the data\n    // the reason for this is because of multitouch\n    // we want to track the movement of this particular touch\n    // this.data = event.data;\n    this.alpha = 0.5;\n    dragTarget = this;\n    app.stage.on('pointermove', onDragMove);\n}\n\nfunction onDragEnd()\n{\n    if (dragTarget)\n    {\n        app.stage.off('pointermove', onDragMove);\n        dragTarget.alpha = 1;\n        dragTarget = null;\n    }\n}\n",hitTestingWithSpatialHash:"import * as PIXI from 'pixi.js';\n\n// This example shows how you can create your own EventBoundary to accelerate\n// hit-testing using spatial hashes. This can be used to optimize relatively\n// \"flat\" scene graphs, where  a container contains so many objects that it\n// covers the whole scene.\n\n// This special event boundary overrides the hit-testing implementation to use\n// HashingContainer's own childHash to find children near the pointer\n// location.\nclass HashingEventBoundary extends PIXI.EventBoundary\n{\n    constructor(...args)\n    {\n        super(...args);\n        // Create reusable temp rectangle for hit-testing!\n        this.tempRect = new PIXI.Rectangle();\n    }\n\n    hitTestRecursive(\n        currentTarget,\n        interactive,\n        location,\n        testFn,\n        pruneFn,\n    )\n    {\n        // If currentTarget isn't a HashingContainer, then default to the\n        // regular hit-testing implementation provided by PixiJS.\n        if (!currentTarget\n                || !currentTarget.visible\n                || !currentTarget.childHash)\n        {\n            return super.hitTestRecursive(\n                currentTarget,\n                interactive,\n                location,\n                testFn,\n                pruneFn,\n            );\n        }\n\n        // Check if the location is outside of the entire container\n        if (pruneFn(currentTarget, location)) return null;\n\n        // Time to get recursive and find the next child in the propagation\n        // path of the event, accelerated using the childHash.\n        if (currentTarget.interactiveChildren)\n        {\n            /* This is where the magic happens! */\n            const tempRect = this.tempRect;\n\n            // Store the location as a 0x0 rectangle. SpatialHash requires a\n            // rectangle for searching.\n            tempRect.x = location.x;\n            tempRect.y = location.y;\n\n            // Find all the children overlapping with tempRect a.k.a location,\n            // and then sort them by their index in the HashingContainer's\n            // children array.\n            const children = Array\n                .from(currentTarget.childHash.search(tempRect))\n                .sort((a, b) => a.refIndex - b.refIndex);\n\n            /* The following is copied from EventBoundary's code. */\n            for (let i = children.length - 1; i >= 0; i--)\n            {\n                const child = children[i];\n                const nestedHit = this.hitTestRecursive(\n                    child,\n                    interactive || child.interactive,\n                    location,\n                    testFn,\n                    pruneFn,\n                );\n\n                if (nestedHit)\n                {\n                    // Its a good idea to check if a child has lost its\n                    // parent. this means it has been removed whilst looping\n                    // so its best\n                    if (nestedHit.length > 0\n                            && !nestedHit[nestedHit.length - 1].parent)\n                    {\n                        // eslint-disable-next-line no-continue\n                        continue;\n                    }\n\n                    // Only add the current hit-test target to the hit-test\n                    // chain if the chain has already started (i.e. the event\n                    // target has been found) or if the current target is\n                    // interactive (i.e. it becomes the event target).\n                    if (nestedHit.length > 0 || currentTarget.interactive)\n                    {\n                        nestedHit.push(currentTarget);\n                    }\n\n                    return nestedHit;\n                }\n            }\n        }\n\n        /* The following is copied from EventBoundary's own implementation. */\n\n        // Finally, hit test this DisplayObject itself.\n        if (interactive && testFn(currentTarget, location))\n        {\n            // The current hit-test target is the event's target only if it\n            // is interactive. Otherwise, the first interactive ancestor will\n            // be the event's target.\n            return currentTarget.interactive ? [currentTarget] : [];\n        }\n\n        return null;\n    }\n}\n\n// HashingContainer is a special kind of container that organizes its children\n// in a spatial hash. It also sets each child's refIndex property to its index\n// in the hashing container's children array.\nclass HashingContainer extends PIXI.Container\n{\n    constructor()\n    {\n        super();\n        this.childHash = new PIXI.SpatialHash();\n    }\n\n    // Override updateTransform to update this.childHash!\n    updateTransform()\n    {\n        super.updateTransform();\n\n        // Reset childHash & re-add all the children. This will\n        // make the spatial hash re-evaluate the coverage of each child.\n        this.childHash.reset();\n        for (let i = 0; i < this.children.length; i++)\n        {\n            const child = this.children[i];\n\n            this.childHash.put(child);\n            child.refIndex = i;\n        }\n    }\n}\n\n// This is the actual program using HashingEventBoundary, HashingContainer.\nfunction main()\n{\n    // Create app. autoStart = false so that the app doesn't render until\n    // something changes - this prevents redundant spatial-hash updates.\n    const app = new PIXI.Application({\n        antialias: true,\n        autoStart: false,\n        background: '#1099bb',\n    });\n\n    document.body.appendChild(app.view);\n\n    // Install our own EventBoundary!\n    app.renderer.events.rootBoundary = new HashingEventBoundary(app.stage);\n\n    // Make the hashing container\n    const container = app.stage.addChild(new HashingContainer());\n    // Textures to choose from for each random character\n    const textures = [\n        PIXI.Texture.from('https://pixijs.com/assets/skully.png'),\n        PIXI.Texture.from('https://pixijs.com/assets/eggHead.png'),\n        PIXI.Texture.from('https://pixijs.com/assets/flowerTop.png'),\n        PIXI.Texture.from('https://pixijs.com/assets/helmlok.png'),\n    ];\n    // Rerender scene when each texture loads\n\n    textures.forEach(\n        (tex) => tex.baseTexture.once('loaded', () => app.render()),\n    );\n\n    // Populate the hashing container!\n    function makeMonster(x, y)\n    {\n        const texture = textures[Math.floor(Math.random() * textures.length)];\n        const sprite = new PIXI.Sprite(texture);\n\n        // Randomly place the character\n        sprite.position.set(\n            x || Math.random() * (app.screen.width - 64),\n            y || (64 + Math.random() * (app.screen.height - 128)),\n        );\n\n        // Make character smaller so we can have a bunch of 'em\n        sprite.scale.set(0.34);\n\n        // Make the character interactive!\n        sprite.eventMode = 'static';\n\n        // Explode on clicks!\n        sprite.addEventListener('click', onMonsterClicked);\n\n        container.addChild(sprite);\n\n        return sprite;\n    }\n    function onMonsterClicked(e)\n    {\n        const monster = this;\n        const pos = monster.position;\n        const radius = Math.max(monster.width, monster.height) * 2;\n\n        // Remove monster from scene once the event finishes propagating.\n        e.manager.dispatch.once('click', () =>\n        {\n            // TODO: Fix PixiJS throwing errors since the monster is removed\n            // from scene graph while was under hover.\n\n            monster.parent.removeChild(monster);\n            PIXI.Ticker.shared.addOnce(() => app.render());\n        });\n\n        for (let i = 0; i < 8; i++)\n        {\n            const x = pos.x + radius * Math.cos(i * Math.PI / 4);\n            const y = pos.y + radius * Math.sin(i * Math.PI / 4);\n\n            makeMonster(x, y);\n        }\n    }\n    // Make initial set of monsters\n    for (let i = 0; i < 100; i++) makeMonster();\n\n    // Add a descriptive title\n    const title = app.stage.addChild(\n        new PIXI.Text(\n            'Click on a monster and see it explode into more!',\n            {\n                fontSize: 12,\n            },\n        ),\n    );\n\n    title.position.set(12, 12);\n\n    // Render the stage once\n    app.render();\n}\n\n// Run our program!\nmain();\n",interactivity:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// create a background...\nconst background = PIXI.Sprite.from('https://pixijs.com/assets/bg_button.jpg');\n\nbackground.width = app.screen.width;\nbackground.height = app.screen.height;\n\n// add background to stage...\napp.stage.addChild(background);\n\n// create some textures from an image path\nconst textureButton = PIXI.Texture.from('https://pixijs.com/assets/button.png');\nconst textureButtonDown = PIXI.Texture.from('https://pixijs.com/assets/button_down.png');\nconst textureButtonOver = PIXI.Texture.from('https://pixijs.com/assets/button_over.png');\n\nconst buttons = [];\n\nconst buttonPositions = [\n    175, 75,\n    655, 75,\n    410, 325,\n    150, 465,\n    685, 445,\n];\n\nfor (let i = 0; i < 5; i++)\n{\n    const button = new PIXI.Sprite(textureButton);\n\n    button.anchor.set(0.5);\n    button.x = buttonPositions[i * 2];\n    button.y = buttonPositions[i * 2 + 1];\n\n    // make the button interactive...\n    button.eventMode = 'static';\n    button.cursor = 'pointer';\n\n    button\n    // Mouse & touch events are normalized into\n    // the pointer* events for handling different\n    // button events.\n        .on('pointerdown', onButtonDown)\n        .on('pointerup', onButtonUp)\n        .on('pointerupoutside', onButtonUp)\n        .on('pointerover', onButtonOver)\n        .on('pointerout', onButtonOut);\n\n    // Use mouse-only events\n    // .on('mousedown', onButtonDown)\n    // .on('mouseup', onButtonUp)\n    // .on('mouseupoutside', onButtonUp)\n    // .on('mouseover', onButtonOver)\n    // .on('mouseout', onButtonOut)\n\n    // Use touch-only events\n    // .on('touchstart', onButtonDown)\n    // .on('touchend', onButtonUp)\n    // .on('touchendoutside', onButtonUp)\n\n    // add it to the stage\n    app.stage.addChild(button);\n\n    // add button to array\n    buttons.push(button);\n}\n\n// set some silly values...\nbuttons[0].scale.set(1.2);\nbuttons[2].rotation = Math.PI / 10;\nbuttons[3].scale.set(0.8);\nbuttons[4].scale.set(0.8, 1.2);\nbuttons[4].rotation = Math.PI;\n\nfunction onButtonDown()\n{\n    this.isdown = true;\n    this.texture = textureButtonDown;\n    this.alpha = 1;\n}\n\nfunction onButtonUp()\n{\n    this.isdown = false;\n    if (this.isOver)\n    {\n        this.texture = textureButtonOver;\n    }\n    else\n    {\n        this.texture = textureButton;\n    }\n}\n\nfunction onButtonOver()\n{\n    this.isOver = true;\n    if (this.isdown)\n    {\n        return;\n    }\n    this.texture = textureButtonOver;\n}\n\nfunction onButtonOut()\n{\n    this.isOver = false;\n    if (this.isdown)\n    {\n        return;\n    }\n    this.texture = textureButton;\n}\n",logger:"import * as PIXI from 'pixi.js';\n\n// This example logs the order of events hover-related events in the scene.\nconst app = new PIXI.Application({\n    antialias: true,\n    background: '#1099bb',\n});\n\ndocument.body.appendChild(app.view);\n\nconst title = app.stage.addChild(new PIXI.Text(\n    `Move your mouse slowly over the boxes to\n    see the order of pointerenter, pointerleave,\n    pointerover, pointerout events on each target!`, {\n        fontSize: 16,\n    },\n));\n\ntitle.x = 2;\n\nconst logs = [];\nconst logText = app.stage.addChild(new PIXI.Text('', {\n    fontSize: 14,\n}));\n\nlogText.y = 80;\nlogText.x = 2;\n\napp.stage.name = 'stage';\n\n// Mount outer black box\nconst blackBox = app.stage.addChild(new PIXI.Graphics()\n    .beginFill(0)\n    .drawRect(0, 0, 400, 400)\n    .endFill());\n\nblackBox.name = 'black box';\nblackBox.x = 400;\n\n// Mount white box inside the white one\nconst whiteBox = blackBox.addChild(new PIXI.Graphics()\n    .beginFill(0xffffff)\n    .drawRect(100, 100, 200, 200)\n    .endFill());\n\nwhiteBox.name = 'white box';\n\n// Enable interactivity everywhere!\napp.stage.eventMode = 'static';\napp.stage.hitArea = app.screen;\nwhiteBox.eventMode = 'static';\nblackBox.eventMode = 'static';\n\nfunction onEvent(e)\n{\n    const type = e.type;\n    const targetName = e.target.name;\n    const currentTargetName = e.currentTarget.name;\n\n    // Add event to top of logs\n    logs.push(`${currentTargetName} received ${type} event (target is ${targetName})`);\n\n    if (currentTargetName === 'stage'\n        || type === 'pointerenter'\n        || type === 'pointerleave')\n    {\n        logs.push('-----------------------------------------', '');\n    }\n\n    // Prevent logs from growing too long\n    if (logs.length > 30)\n    {\n        while (logs.length > 30)\n        {\n            logs.shift();\n        }\n    }\n\n    // Update logText\n    logText.text = logs.join('\\n');\n}\n\n[app.stage, whiteBox, blackBox].forEach((object) =>\n{\n    object.addEventListener('pointerenter', onEvent);\n    object.addEventListener('pointerleave', onEvent);\n    object.addEventListener('pointerover', onEvent);\n    object.addEventListener('pointerout', onEvent);\n});\n",nestedBoundaryWithProjection:"import * as PIXI from 'pixi.js';\nimport '@pixi/graphics-extras';\n\n// This example shows how you can setup a nested boundary to propagate events\n// into a disjoint scene graph. Here, a camera is used to project an different\n// world onto the canvas.\n\nconst app = new PIXI.Application({\n    antialias: true,\n    background: '#1099bb',\n});\n\ndocument.body.appendChild(app.view);\n\n// A projector renders it's content using projection. The transforms in\n// the contents scene graph don't change if you move the camera. To achieve\n// this, the content is not added as a \"child\" to the projector; however, this\n// means events won't propagate into the content by default.\n//\n// To solve this, we nest our own EventBoundary, and connect it using\n// addEventListener!\nclass Projector extends PIXI.DisplayObject\n{\n    constructor()\n    {\n        super();\n\n        // The content root to be rendered by this camera.\n        this.content = new PIXI.Container();\n\n        // Temporary matrix to store the original projection transform.\n        this.originalTransform = new PIXI.Matrix();\n\n        // The event boundary that'll map events downstream into the content\n        // scene.\n        this.boundary = new PIXI.EventBoundary(this.content);\n\n        // Override copyMouseData to apply inverse worldTransform on\n        // global coords\n        this.boundary.copyMouseData = (from, to) =>\n        {\n            // Apply default implementation first\n            PIXI.EventBoundary.prototype.copyMouseData.call(this.boundary, from, to);\n\n            // Then bring global coords into content's world\n            this.worldTransform.applyInverse(to.global, to.global);\n            // TODO: Remove after https://github.com/pixijs/pixi.js/pull/7381\n            // is merged!\n            to.target = this.boundary.hitTest(to.global.x, to.global.y);\n        };\n\n        // Propagate these events down into the content's scene graph!\n        [\n            'pointerdown',\n            'pointerup',\n            'pointermove',\n            'pointerover',\n            'pointerout',\n            'wheel',\n        ].forEach((event) =>\n        {\n            this.addEventListener(event, (e) => this.boundary.mapEvent(e));\n        });\n\n        this.eventMode = 'static';\n    }\n\n    // Pass through cursor\n    get cursor()\n    {\n        return this.boundary.cursor;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    set cursor(value)\n    {\n        throw new Error('The camera\\'s cursor is derived from its content!');\n    }\n\n    // Pass through calculateBounds\n    calculateBounds()\n    {\n        const contentBounds = this.content.getBounds();\n\n        this._bounds.addFrameMatrix(\n            this.worldTransform,\n            contentBounds.x,\n            contentBounds.y,\n            contentBounds.width,\n            contentBounds.height,\n        );\n    }\n\n    // Pass through containsPoint\n    containsPoint(point)\n    {\n        return !!this.boundary.hitTest(point.x, point.y);\n    }\n\n    // Render content with projection\n    render(renderer)\n    {\n        renderer.batch.flush();\n\n        const projectionSystem = renderer.projection;\n        const renderTextureSystem = renderer.renderTexture;\n\n        projectionSystem.transform = projectionSystem.transform\n            || new PIXI.Matrix();\n        projectionSystem.transform.copyTo(this.originalTransform);\n        projectionSystem.transform.append(this.worldTransform);\n        projectionSystem.update(null, null, 1, !renderTextureSystem.current);\n\n        this.content.render(renderer);\n\n        renderer.batch.flush();\n\n        projectionSystem.transform.copyFrom(this.originalTransform);\n        projectionSystem.update(null, null, 1, !renderTextureSystem.current);\n    }\n\n    // updateTransform also updates content's transform\n    updateTransform()\n    {\n        super.updateTransform();\n\n        this.content.enableTempParent();\n        this.content.updateTransform();\n        this.content.disableTempParent(null);\n    }\n}\n\n// The projector\nconst projector = app.stage.addChild(new Projector());\n\n// Add coordinate axes!\nprojector.content.addChild(\n    new PIXI.Graphics()\n        .lineStyle({ color: 0, alpha: 0.2, width: 2 })\n        .moveTo(0, -300)\n        .lineTo(0, 600)\n        .moveTo(-100, 0)\n        .lineTo(700, 0),\n);\n\n// Construct the star Graphics\nconst stars = [1, 2, 3].map((i) => new PIXI.Graphics()\n    .beginFill(0xffffff, 0.75)\n    .drawStar(0, 0, 18 / i, 100 * i / 2));\n\n// Place the stars\nstars[0].x = 0;\nstars[1].x = 200;\nstars[2].x = 500;\n\n// Add stars to the projector\nprojector.content.addChild(...stars);\n\n// Make projection x+100, y+300\nprojector.x = 100;\nprojector.y = 300;\nprojector.content.hitArea = new PIXI.Rectangle(-100, -300, app.screen.width, app.screen.height);\n// Make hit-area cover the whole screen so we can capture\n// pointermove everywhere!\nprojector.hitArea = projector.content.hitArea;\nprojector.content.eventMode = 'static';\n\n// Make stars interactive & add wheel handlers\nstars.forEach((star) =>\n{\n    // Make star interactive\n    star.eventMode = 'static';\n\n    // Set initial cursor\n    star.cursor = 'zoom-in';\n\n    // Add wheel rotation feedback\n    star.addEventListener('wheel', (e) =>\n    {\n        const scroll = Math.sign(e.deltaY) * Math.min(15, Math.abs(e.deltaY));\n\n        star.rotation += scroll / 100;\n    });\n\n    // Add click zoom-in/zoom-out handler\n    star.addEventListener('click', (e) =>\n    {\n        if (star.scale.x === 1)\n        {\n            star.scale.set(1.33);\n            star.cursor = 'zoom-out';\n        }\n        else\n        {\n            star.scale.set(1);\n            star.cursor = 'zoom-in';\n        }\n    });\n});\n\nPIXI.BitmapFont.from('coordinates', {\n    fontFamily: 'Roboto',\n    fontSize: 16,\n    fill: '#272d37',\n}, { chars: ['Global:() Screen-.,', ['0', '9']] });\n\nconst coordinates = new PIXI.BitmapText('Global: (0, 0)\\nScreen: (0, 0)', {\n    fontName: 'coordinates',\n});\n\ncoordinates.x = 110;\ncoordinates.y = 550;\n\napp.stage.addChild(coordinates);\n\nprojector.content.addEventListener('pointermove', (e) =>\n{\n    const global = `(${e.global.x | 0}, ${e.global.y | 0})`;\n    const screen = `(${e.screen.x | 0}, ${e.screen.y | 0})`;\n\n    coordinates.text = `Global: ${global}\\nScreen: ${screen}`;\n});\n\nconst description = new PIXI.Text(\n    'The (0, 0) world coordinates for the content is located at the center of the first star!'\n    + '\\n  * Mouse wheel over stars to rotate them'\n    + '\\n  * Click to zoom in or out', {\n        fontSize: 16,\n        fontFamily: 'Roboto',\n        fill: '#272d37',\n    },\n);\n\ndescription.position.set(110, 12);\n\napp.stage.addChild(description);\n",pointerTracker:"import * as PIXI from 'pixi.js';\n\n// In this a example, a circle will follow the pointer wherever it\n// moves over the canvas.\n\nconst app = new PIXI.Application({\n    antialias: true,\n    background: '#1099bb',\n});\n\ndocument.body.appendChild(app.view);\n\n// Create the circle\nconst circle = app.stage.addChild(new PIXI.Graphics()\n    .beginFill(0xffffff)\n    .lineStyle({ color: 0x111111, alpha: 0.87, width: 1 })\n    .drawCircle(0, 0, 8)\n    .endFill());\n\ncircle.position.set(app.screen.width / 2, app.screen.height / 2);\n\n// Enable interactivity!\napp.stage.eventMode = 'static';\n\n// Make sure the whole canvas area is interactive, not just the circle.\napp.stage.hitArea = app.screen;\n\n// Follow the pointer\napp.stage.addEventListener('pointermove', (e) =>\n{\n    circle.position.copyFrom(e.global);\n});\n",slider:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({\n    antialias: true,\n    background: '#1099bb',\n});\n\ndocument.body.appendChild(app.view);\n\nconst stageHeight = app.screen.height;\nconst stageWidth = app.screen.width;\n\n// Make sure stage covers the whole scene\napp.stage.hitArea = app.screen;\n\n// Make the slider\nconst sliderWidth = 320;\nconst slider = new PIXI.Graphics()\n    .beginFill(0x272d37)\n    .drawRect(0, 0, sliderWidth, 4);\n\nslider.x = (stageWidth - sliderWidth) / 2;\nslider.y = stageHeight * 0.75;\n\n// Draw the handle\nconst handle = new PIXI.Graphics()\n    .beginFill(0xffffff)\n    .drawCircle(0, 0, 8);\n\nhandle.y = slider.height / 2;\nhandle.x = sliderWidth / 2;\nhandle.eventMode = 'static';\nhandle.cursor = 'pointer';\n\nhandle\n    .on('pointerdown', onDragStart)\n    .on('pointerup', onDragEnd)\n    .on('pointerupoutside', onDragEnd);\n\napp.stage.addChild(slider);\nslider.addChild(handle);\n\n// Add bunny whose scale can be changed by user using slider\nconst bunny = app.stage.addChild(PIXI.Sprite.from('https://pixijs.com/assets/bunny.png'));\n\nbunny.texture.baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;\nbunny.scale.set(3);\nbunny.anchor.set(0.5);\nbunny.x = stageWidth / 2;\nbunny.y = stageHeight / 2;\n\n// Add title\nconst title = new PIXI.Text('Drag the handle to change the scale of bunny.', {\n    fill: '#272d37',\n    fontFamily: 'Roboto',\n    fontSize: 20,\n    align: 'center',\n});\n\ntitle.roundPixels = true;\ntitle.x = stageWidth / 2;\ntitle.y = 40;\ntitle.anchor.set(0.5, 0);\napp.stage.addChild(title);\n\n// Listen to pointermove on stage once handle is pressed.\nfunction onDragStart()\n{\n    app.stage.eventMode = 'static';\n    app.stage.addEventListener('pointermove', onDrag);\n}\n\n// Stop dragging feedback once the handle is released.\nfunction onDragEnd(e)\n{\n    app.stage.eventMode = 'auto';\n    app.stage.removeEventListener('pointermove', onDrag);\n}\n\n// Update the handle's position & bunny's scale when the handle is moved.\nfunction onDrag(e)\n{\n    const halfHandleWidth = handle.width / 2;\n    // Set handle y-position to match pointer, clamped to (4, screen.height - 4).\n\n    handle.x = Math.max(halfHandleWidth, Math.min(\n        slider.toLocal(e.global).x,\n        sliderWidth - halfHandleWidth,\n    ));\n    // Normalize handle position between -1 and 1.\n    const t = 2 * ((handle.x / sliderWidth) - 0.5);\n\n    bunny.scale.set(3 * (1.1 + t));\n}\n"},masks:{filter:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// Inner radius of the circle\nconst radius = 100;\n\n// The blur amount\nconst blurSize = 32;\n\nPIXI.Assets.load('https://pixijs.com/assets/bg_grass.jpg').then((grassTexture) =>\n{\n    const background = new PIXI.Sprite(grassTexture);\n\n    app.stage.addChild(background);\n    background.width = app.screen.width;\n    background.height = app.screen.height;\n\n    const circle = new PIXI.Graphics()\n        .beginFill(0xFF0000)\n        .drawCircle(radius + blurSize, radius + blurSize, radius)\n        .endFill();\n\n    circle.filters = [new PIXI.filters.BlurFilter(blurSize)];\n\n    const bounds = new PIXI.Rectangle(0, 0, (radius + blurSize) * 2, (radius + blurSize) * 2);\n    const texture = app.renderer.generateTexture(circle, PIXI.SCALE_MODES.NEAREST, 1, bounds);\n    const focus = new PIXI.Sprite(texture);\n\n    app.stage.addChild(focus);\n    background.mask = focus;\n\n    app.stage.eventMode = 'static';\n    app.stage.hitArea = app.screen;\n    app.stage.on('pointermove', (event) =>\n    {\n        focus.position.x = event.global.x - focus.width / 2;\n        focus.position.y = event.global.y - focus.height / 2;\n    });\n});\n",graphics:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ antialias: true, resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\napp.stage.eventMode = 'static';\n\nconst bg = PIXI.Sprite.from('https://pixijs.com/assets/bg_rotate.jpg');\n\nbg.anchor.set(0.5);\n\nbg.x = app.screen.width / 2;\nbg.y = app.screen.height / 2;\n\napp.stage.addChild(bg);\n\nconst container = new PIXI.Container();\n\ncontainer.x = app.screen.width / 2;\ncontainer.y = app.screen.height / 2;\n\n// add a bunch of sprites\nconst bgFront = PIXI.Sprite.from('https://pixijs.com/assets/bg_scene_rotate.jpg');\n\nbgFront.anchor.set(0.5);\n\nconst light2 = PIXI.Sprite.from('https://pixijs.com/assets/light_rotate_2.png');\n\nlight2.anchor.set(0.5);\n\nconst light1 = PIXI.Sprite.from('https://pixijs.com/assets/light_rotate_1.png');\n\nlight1.anchor.set(0.5);\n\nconst panda = PIXI.Sprite.from('https://pixijs.com/assets/panda.png');\n\npanda.anchor.set(0.5);\n\ncontainer.addChild(bgFront, light2, light1, panda);\n\napp.stage.addChild(container);\n\n// let's create a moving shape\nconst thing = new PIXI.Graphics();\n\napp.stage.addChild(thing);\nthing.x = app.screen.width / 2;\nthing.y = app.screen.height / 2;\nthing.lineStyle(0);\n\ncontainer.mask = thing;\n\nlet count = 0;\n\napp.stage.on('pointertap', () =>\n{\n    if (!container.mask)\n    {\n        container.mask = thing;\n    }\n    else\n    {\n        container.mask = null;\n    }\n});\n\nconst help = new PIXI.Text('Click or tap to turn masking on / off.', {\n    fontFamily: 'Arial',\n    fontSize: 12,\n    fontWeight: 'bold',\n    fill: 'white',\n});\n\nhelp.y = app.screen.height - 26;\nhelp.x = 10;\napp.stage.addChild(help);\n\napp.ticker.add(() =>\n{\n    bg.rotation += 0.01;\n    bgFront.rotation -= 0.01;\n\n    light1.rotation += 0.02;\n    light2.rotation += 0.01;\n\n    panda.scale.x = 1 + Math.sin(count) * 0.04;\n    panda.scale.y = 1 + Math.cos(count) * 0.04;\n\n    count += 0.1;\n\n    thing.clear();\n\n    thing.beginFill(0x8bc5ff, 0.4);\n    thing.moveTo(-120 + Math.sin(count) * 20, -100 + Math.cos(count) * 20);\n    thing.lineTo(120 + Math.cos(count) * 20, -100 + Math.sin(count) * 20);\n    thing.lineTo(120 + Math.sin(count) * 20, 100 + Math.cos(count) * 20);\n    thing.lineTo(-120 + Math.cos(count) * 20, 100 + Math.sin(count) * 20);\n    thing.rotation = count * 0.1;\n});\n",sprite:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\napp.stage.eventMode = 'static';\n\nconst bg = PIXI.Sprite.from('https://pixijs.com/assets/bg_plane.jpg');\n\napp.stage.addChild(bg);\n\nconst cells = PIXI.Sprite.from('https://pixijs.com/assets/cells.png');\n\ncells.scale.set(1.5);\n\nconst mask = PIXI.Sprite.from('https://pixijs.com/assets/flowerTop.png');\n\nmask.anchor.set(0.5);\nmask.x = 310;\nmask.y = 190;\n\ncells.mask = mask;\n\napp.stage.addChild(mask, cells);\n\nconst target = new PIXI.Point();\n\nreset();\n\nfunction reset()\n{\n    target.x = Math.floor(Math.random() * 550);\n    target.y = Math.floor(Math.random() * 300);\n}\n\napp.ticker.add(() =>\n{\n    mask.x += (target.x - mask.x) * 0.1;\n    mask.y += (target.y - mask.y) * 0.1;\n\n    if (Math.abs(mask.x - target.x) < 1)\n    {\n        reset();\n    }\n});\n"},textures:{gradientBasic:"import * as PIXI from 'pixi.js';\n\n// This demo uses canvas2d gradient API\n// https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/createLinearGradient\n\nconst app = new PIXI.Application({ antialias: true, resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nfunction createGradTexture()\n{\n    // adjust it if somehow you need better quality for very very big images\n    const quality = 256;\n    const canvas = document.createElement('canvas');\n\n    canvas.width = quality;\n    canvas.height = 1;\n\n    const ctx = canvas.getContext('2d');\n\n    // use canvas2d API to create gradient\n    const grd = ctx.createLinearGradient(0, 0, quality, 0);\n\n    grd.addColorStop(0, 'rgba(255, 255, 255, 0.0)');\n    grd.addColorStop(0.3, 'cyan');\n    grd.addColorStop(0.7, 'red');\n    grd.addColorStop(1, 'green');\n\n    ctx.fillStyle = grd;\n    ctx.fillRect(0, 0, quality, 1);\n\n    return PIXI.Texture.from(canvas);\n}\n\nconst gradTexture = createGradTexture();\n\nconst sprite = new PIXI.Sprite(gradTexture);\n\nsprite.position.set(100, 100);\nsprite.rotation = Math.PI / 8;\nsprite.width = 500;\nsprite.height = 50;\napp.stage.addChild(sprite);\n",gradientResource:"import * as PIXI from 'pixi.js';\n\n// PixiJS V5 Texture-Resource API + canvas2d gradient API + WebGL texImage2D\n// Look here for advanced upload function:\n// https://github.com/pixijs/pixi.js/blob/dev/packages/core/src/textures/resources/BaseImageResource.js#L54\n\nclass GradientResource extends PIXI.Resource\n{\n    constructor()\n    {\n    // pass width and height. (0,0) if we dont know yet\n    // gradient needs only 1 pixel height\n        super(256, 1);\n    }\n\n    upload(renderer, baseTexture, glTexture)\n    {\n        const { width } = this; // default size or from baseTexture?\n        const { height } = this; // your choice.\n\n        // temporary canvas, we dont need it after texture is uploaded to GPU\n        const canvas = document.createElement('canvas');\n\n        canvas.width = width;\n        canvas.height = height;\n\n        const ctx = canvas.getContext('2d');\n\n        const grd = ctx.createLinearGradient(0, 0, width, 0);\n\n        grd.addColorStop(0, 'rgba(255, 255, 255, 0.0)');\n        grd.addColorStop(0.3, 'cyan');\n        grd.addColorStop(0.7, 'red');\n        grd.addColorStop(1, 'green');\n\n        ctx.fillStyle = grd;\n        ctx.fillRect(0, 0, width, height);\n\n        // This info ios usseful if upload happens second time\n        // Some people use that to track used memory\n        glTexture.width = width;\n        glTexture.height = height;\n\n        // PURE WEBGL CALLS - that's what its all about.\n        // PixiJS cant wrap all that API, we give you acceess to it!\n        const { gl } = renderer;\n\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha);\n        gl.texImage2D(baseTexture.target, 0, baseTexture.format, baseTexture.format, baseTexture.type, canvas);\n\n        return true;\n    }\n}\n\nconst app = new PIXI.Application({ antialias: true, resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nconst gradBaseTexture = new PIXI.BaseTexture(new GradientResource());\n// Here you can fake baseTexture size to avoid resizing all sprites\n// There can be multiple baseTextures per gradient, but be careful:\n// resource will spawn more glTextures!\n\ngradBaseTexture.setSize(500, 50);\n\nconst gradTexture = new PIXI.Texture(gradBaseTexture);\n\nconst sprite = new PIXI.Sprite(gradTexture);\n\nsprite.position.set(100, 100);\nsprite.rotation = Math.PI / 8;\napp.stage.addChild(sprite);\n",renderTextureAdvanced:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nconst stageSize = {\n    width: app.screen.width,\n    height: app.screen.height,\n};\n\n// create two render textures... these dynamic textures will be used to draw the scene into itself\nlet renderTexture = PIXI.RenderTexture.create(stageSize);\nlet renderTexture2 = PIXI.RenderTexture.create(stageSize);\nconst currentTexture = renderTexture;\n\n// create a new sprite that uses the render texture we created above\nconst outputSprite = new PIXI.Sprite(currentTexture);\n\n// align the sprite\noutputSprite.x = 400;\noutputSprite.y = 300;\noutputSprite.anchor.set(0.5);\n\n// add to stage\napp.stage.addChild(outputSprite);\n\nconst stuffContainer = new PIXI.Container();\n\nstuffContainer.x = 400;\nstuffContainer.y = 300;\n\napp.stage.addChild(stuffContainer);\n\n// create an array of image ids..\nconst fruits = [\n    'https://pixijs.com/assets/rt_object_01.png',\n    'https://pixijs.com/assets/rt_object_02.png',\n    'https://pixijs.com/assets/rt_object_03.png',\n    'https://pixijs.com/assets/rt_object_04.png',\n    'https://pixijs.com/assets/rt_object_05.png',\n    'https://pixijs.com/assets/rt_object_06.png',\n    'https://pixijs.com/assets/rt_object_07.png',\n    'https://pixijs.com/assets/rt_object_08.png',\n];\n\n// create an array of items\nconst items = [];\n\n// now create some items and randomly position them in the stuff container\nfor (let i = 0; i < 20; i++)\n{\n    const item = PIXI.Sprite.from(fruits[i % fruits.length]);\n\n    item.x = Math.random() * 400 - 200;\n    item.y = Math.random() * 400 - 200;\n    item.anchor.set(0.5);\n    stuffContainer.addChild(item);\n    items.push(item);\n}\n\n// used for spinning!\nlet count = 0;\n\napp.ticker.add(() =>\n{\n    for (let i = 0; i < items.length; i++)\n    {\n    // rotate each item\n        const item = items[i];\n\n        item.rotation += 0.1;\n    }\n\n    count += 0.01;\n\n    // swap the buffers ...\n    const temp = renderTexture;\n\n    renderTexture = renderTexture2;\n    renderTexture2 = temp;\n\n    // set the new texture\n    outputSprite.texture = renderTexture;\n\n    // twist this up!\n    stuffContainer.rotation -= 0.01;\n    outputSprite.scale.set(1 + Math.sin(count) * 0.2);\n\n    // render the stage to the texture\n    // the 'true' clears the texture before the content is rendered\n    app.renderer.render(app.stage, {\n        renderTexture: renderTexture2,\n        clear: false,\n    });\n});\n",renderTextureBasic:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ background: '#1099bb', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nconst container = new PIXI.Container();\n\napp.stage.addChild(container);\n\nconst texture = PIXI.Texture.from('https://pixijs.com/assets/bunny.png');\n\nfor (let i = 0; i < 25; i++)\n{\n    const bunny = new PIXI.Sprite(texture);\n\n    bunny.x = (i % 5) * 30;\n    bunny.y = Math.floor(i / 5) * 30;\n    bunny.rotation = Math.random() * (Math.PI * 2);\n    container.addChild(bunny);\n}\n\nconst rt = PIXI.RenderTexture.create({\n    width: 300,\n    height: 300,\n    scaleMode: PIXI.SCALE_MODES.LINEAR,\n    resolution: 1,\n});\n\nconst sprite = new PIXI.Sprite(rt);\n\nsprite.x = 450;\nsprite.y = 60;\napp.stage.addChild(sprite);\n\n/*\n * All the bunnies are added to the container with the addChild method\n * when you do this, all the bunnies become children of the container, and when a container moves,\n * so do all its children.\n * This gives you a lot of flexibility and makes it easier to position elements on the screen\n */\ncontainer.x = 100;\ncontainer.y = 60;\n\napp.ticker.add(() =>\n{\n    app.renderer.render(container, { renderTexture: rt });\n});\n",textureRotate:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nPIXI.Assets.load('https://pixijs.com/assets/flowerTop.png').then((texture) =>\n{\n    // create rotated textures\n    const textures = [texture];\n    const D8 = PIXI.groupD8;\n\n    for (let rotate = 1; rotate < 16; rotate++)\n    {\n        const h = D8.isVertical(rotate) ? texture.frame.width : texture.frame.height;\n        const w = D8.isVertical(rotate) ? texture.frame.height : texture.frame.width;\n\n        const { frame } = texture;\n        const crop = new PIXI.Rectangle(texture.frame.x, texture.frame.y, w, h);\n        const trim = crop;\n        let rotatedTexture;\n\n        if (rotate % 2 === 0)\n        {\n            rotatedTexture = new PIXI.Texture(texture.baseTexture, frame, crop, trim, rotate);\n        }\n        else\n        {\n            // HACK to avoid exception\n            // PIXI doesnt like diamond-shaped UVs, because they are different in canvas and webgl\n            rotatedTexture = new PIXI.Texture(texture.baseTexture, frame, crop, trim, rotate - 1);\n            rotatedTexture.rotate++;\n        }\n        textures.push(rotatedTexture);\n    }\n\n    const offsetX = app.screen.width / 16 | 0;\n    const offsetY = app.screen.height / 8 | 0;\n    const gridW = app.screen.width / 4 | 0;\n    const gridH = app.screen.height / 5 | 0;\n\n    // normal rotations and mirrors\n    for (let i = 0; i < 16; i++)\n    {\n        // create a new Sprite using rotated texture\n        const dude = new PIXI.Sprite(textures[i < 8 ? i * 2 : (i - 8) * 2 + 1]);\n\n        dude.scale.x = 0.5;\n        dude.scale.y = 0.5;\n        // show it in grid\n        dude.x = offsetX + gridW * (i % 4);\n        dude.y = offsetY + gridH * (i / 4 | 0);\n        app.stage.addChild(dude);\n        const text = new PIXI.Text(`rotate = ${dude.texture.rotate}`, {\n            fontFamily: 'Courier New', fontSize: '12px', fill: 'white', align: 'left',\n        });\n\n        text.x = dude.x;\n        text.y = dude.y - 20;\n        app.stage.addChild(text);\n    }\n});\n"},assets:{async:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ background: '#1099bb', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// await can only be used inside an async function\nasync function init()\n{\n    const texture = await PIXI.Assets.load('https://pixijs.com/assets/bunny.png');\n\n    // create a new Sprite from the awaited loaded Texture\n    const bunny = PIXI.Sprite.from(texture);\n\n    // center the sprite's anchor point\n    bunny.anchor.set(0.5);\n\n    // move the sprite to the center of the screen\n    bunny.x = app.screen.width / 2;\n    bunny.y = app.screen.height / 2;\n\n    app.stage.addChild(bunny);\n}\n\n// Call that async function\ninit();\n",background:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ background: '#1099bb', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// Add the assets to load\nPIXI.Assets.add('flowerTop', 'https://pixijs.com/assets/flowerTop.png');\nPIXI.Assets.add('eggHead', 'https://pixijs.com/assets/eggHead.png');\n\n// Allow the assets to load in the background\nPIXI.Assets.backgroundLoad(['flowerTop', 'eggHead']);\n\n// If the background load hasn't loaded this asset yet, calling load forces this asset to load now.\nPIXI.Assets.load('eggHead').then((texture) =>\n{\n    // auxiliar flag for toggling the texture\n    let isEggHead = true;\n\n    // create a new Sprite from the resolved loaded texture\n    const character = new PIXI.Sprite(texture);\n\n    character.anchor.set(0.5);\n    character.x = app.screen.width / 2;\n    character.y = app.screen.height / 2;\n    character.eventMode = 'static';\n    character.cursor = 'pointer';\n\n    app.stage.addChild(character);\n\n    character.on('pointertap', async () =>\n    {\n        isEggHead = !isEggHead;\n        // These promise are already resolved in the cache.\n        character.texture = await PIXI.Assets.load(isEggHead ? 'eggHead' : 'flowerTop');\n    });\n});\n",bundle:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ background: '#1099bb', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nasync function init()\n{\n    // manifest example\n    const manifestExample = {\n        bundles: [{\n            name: 'load-screen',\n            assets: [\n                {\n                    name: 'flowerTop',\n                    srcs: 'https://pixijs.com/assets/flowerTop.png',\n                },\n            ],\n        },\n        {\n            name: 'game-screen',\n            assets: [\n                {\n                    name: 'eggHead',\n                    srcs: 'https://pixijs.com/assets/eggHead.png',\n                },\n            ],\n        }],\n    };\n\n    await PIXI.Assets.init({ manifest: manifestExample });\n\n    // bundles can be loaded in the background too!\n    PIXI.Assets.backgroundLoadBundle(['load-screen', 'game-screen']);\n\n    makeLoadScreen();\n}\n\nasync function makeLoadScreen()\n{\n    // get the assets from the load screen bundle.\n    // If the bundle was already downloaded the promise resolves instantly!\n    const loadScreenAssets = await PIXI.Assets.loadBundle('load-screen');\n\n    // create a new Sprite from the resolved loaded texture\n    const goNext = new PIXI.Sprite(loadScreenAssets.flowerTop);\n\n    goNext.anchor.set(0.5);\n    goNext.x = app.screen.width / 2;\n    goNext.y = app.screen.height / 2;\n    app.stage.addChild(goNext);\n\n    goNext.eventMode = 'static';\n    goNext.cursor = 'pointer';\n\n    goNext.on('pointertap', async () =>\n    {\n        goNext.destroy();\n        makeGameScreen();\n    });\n}\n\nasync function makeGameScreen()\n{\n    // Wait here until you get the assets\n    // If the user spends enough time in the load screen by the time they reach the game screen\n    // the assets are completely loaded and the promise resolves instantly!\n    const loadScreenAssets = await PIXI.Assets.loadBundle('game-screen');\n\n    // create a new Sprite from the resolved loaded texture\n    const goBack = new PIXI.Sprite(loadScreenAssets.eggHead);\n\n    goBack.anchor.set(0.5);\n    goBack.x = app.screen.width / 2;\n    goBack.y = app.screen.height / 2;\n    app.stage.addChild(goBack);\n\n    goBack.eventMode = 'static';\n    goBack.cursor = 'pointer';\n\n    goBack.on('pointertap', async () =>\n    {\n        goBack.destroy();\n        // The user can go back and the files are already downloaded\n        makeLoadScreen();\n    });\n}\n\ninit();\n",multiple:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ background: '#1099bb', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// Add the assets to load\nPIXI.Assets.add('flowerTop', 'https://pixijs.com/assets/flowerTop.png');\nPIXI.Assets.add('eggHead', 'https://pixijs.com/assets/eggHead.png');\n\n// Load the assets and get a resolved promise once both are loaded\nconst texturesPromise = PIXI.Assets.load(['flowerTop', 'eggHead']); // => Promise<{flowerTop: Texture, eggHead: Texture}>\n\n// When the promise resolves, we have the texture!\ntexturesPromise.then((textures) =>\n{\n    // create a new Sprite from the resolved loaded Textures\n\n    const flower = PIXI.Sprite.from(textures.flowerTop);\n\n    flower.anchor.set(0.5);\n    flower.x = app.screen.width * 0.25;\n    flower.y = app.screen.height / 2;\n    app.stage.addChild(flower);\n\n    const egg = PIXI.Sprite.from(textures.eggHead);\n\n    egg.anchor.set(0.5);\n    egg.x = app.screen.width * 0.75;\n    egg.y = app.screen.height / 2;\n    app.stage.addChild(egg);\n});\n",promise:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ background: '#1099bb', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// Start loading right away and create a promise\nconst texturePromise = PIXI.Assets.load('https://pixijs.com/assets/bunny.png');\n\n// When the promise resolves, we have the texture!\ntexturePromise.then((resolvedTexture) =>\n{\n    // create a new Sprite from the resolved loaded Texture\n    const bunny = PIXI.Sprite.from(resolvedTexture);\n\n    // center the sprite's anchor point\n    bunny.anchor.set(0.5);\n\n    // move the sprite to the center of the screen\n    bunny.x = app.screen.width / 2;\n    bunny.y = app.screen.height / 2;\n\n    app.stage.addChild(bunny);\n});\n"},offscreenCanvas:{basic:"import * as PIXI from 'pixi.js';\n\n// This example is the based on basic/container, but using OffscreenCanvas.\n\nconst canvas = document.createElement('canvas');\nconst view = canvas.transferControlToOffscreen();\n\nconst app = new PIXI.Application({ view, background: 0x1099bb, resizeTo: window });\n\ndocument.body.appendChild(canvas);\n\nconst container = new PIXI.Container();\n\napp.stage.addChild(container);\n\n// Create a new texture\nconst texture = PIXI.Texture.from('https://pixijs.com/assets/bunny.png');\n\n// Create a 5x5 grid of bunnies\nfor (let i = 0; i < 25; i++)\n{\n    const bunny = new PIXI.Sprite(texture);\n\n    bunny.anchor.set(0.5);\n    bunny.x = (i % 5) * 40;\n    bunny.y = Math.floor(i / 5) * 40;\n    container.addChild(bunny);\n}\n\n// Move container to the center\ncontainer.x = app.screen.width / 2;\ncontainer.y = app.screen.height / 2;\n\n// Center bunny sprite in local container coordinates\ncontainer.pivot.x = container.width / 2;\ncontainer.pivot.y = container.height / 2;\n\n// Listen for animate update\napp.ticker.add((delta) =>\n{\n    // rotate the container!\n    // use delta to create frame-independent transform\n    container.rotation -= 0.01 * delta;\n});\n",webWorker:"import * as PIXI from '@pixi/webworker';\n\n// This example is the based on basic/container, but running in Web Worker.\n\nfunction workerSource(self)\n{\n    self.onmessage = async ({\n        data: { baseUrl, pixiWebWorkerUrl, options },\n    }) =>\n    {\n        self.importScripts(new URL(pixiWebWorkerUrl, baseUrl));\n\n        const app = new PIXI.Application(options);\n\n        document.body.appendChild(app.view);\n\n        const container = new PIXI.Container();\n\n        app.stage.addChild(container);\n\n        // Create a new texture\n        const textureUrl = new URL('https://pixijs.com/assets/bunny.png', baseUrl).toString();\n        const texture = PIXI.Texture.from(textureUrl);\n\n        // Create a 5x5 grid of bunnies\n        for (let i = 0; i < 25; i++)\n        {\n            const bunny = new PIXI.Sprite(texture);\n\n            bunny.anchor.set(0.5);\n            bunny.x = (i % 5) * 40;\n            bunny.y = Math.floor(i / 5) * 40;\n            container.addChild(bunny);\n        }\n\n        // Move container to the center\n        container.x = app.screen.width / 2;\n        container.y = app.screen.height / 2;\n\n        // Center bunny sprite in local container coordinates\n        container.pivot.x = container.width / 2;\n        container.pivot.y = container.height / 2;\n\n        // Listen for animate update\n        app.ticker.add((delta) =>\n        {\n            // rotate the container!\n            // use delta to create frame-independent transform\n            container.rotation -= 0.01 * delta;\n        });\n    };\n}\n\nconst blob = new Blob(['(', workerSource, ')(self);'], { type: 'application/javascript' });\n\nconst url = URL.createObjectURL(blob);\nconst worker = new Worker(url);\n\nURL.revokeObjectURL(url);\n\nconst width = 800;\nconst height = 600;\nconst resolution = window.devicePixelRatio;\nconst canvas = document.createElement('canvas');\n\ncanvas.style.width = `${width}px`;\ncanvas.style.height = `${height}px`;\nconst view = canvas.transferControlToOffscreen();\n\nconst baseUrl = window.location.href;\nconst pixiWebWorkerUrl = window.PIXI_WEBWORKER_URL;\n\nworker.postMessage({\n    baseUrl,\n    pixiWebWorkerUrl,\n    options: {\n        width, height, resolution, view, background: 0x1099bb,\n    },\n}, [view]);\n"},filtersBasic:{blur:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nconst bg = PIXI.Sprite.from('https://pixijs.com/assets/pixi-filters/bg_depth_blur.jpg');\n\nbg.width = app.screen.width;\nbg.height = app.screen.height;\napp.stage.addChild(bg);\n\nconst littleDudes = PIXI.Sprite.from('https://pixijs.com/assets/pixi-filters/depth_blur_dudes.jpg');\n\nlittleDudes.x = (app.screen.width / 2) - 315;\nlittleDudes.y = 200;\napp.stage.addChild(littleDudes);\n\nconst littleRobot = PIXI.Sprite.from('https://pixijs.com/assets/pixi-filters/depth_blur_moby.jpg');\n\nlittleRobot.x = (app.screen.width / 2) - 200;\nlittleRobot.y = 100;\napp.stage.addChild(littleRobot);\n\nconst blurFilter1 = new PIXI.filters.BlurFilter();\nconst blurFilter2 = new PIXI.filters.BlurFilter();\n\nlittleDudes.filters = [blurFilter1];\nlittleRobot.filters = [blurFilter2];\n\nlet count = 0;\n\napp.ticker.add(() =>\n{\n    count += 0.005;\n\n    const blurAmount = Math.cos(count);\n    const blurAmount2 = Math.sin(count);\n\n    blurFilter1.blur = 20 * (blurAmount);\n    blurFilter2.blur = 20 * (blurAmount2);\n});\n",colorMatrix:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\napp.stage.eventMode = 'static';\n\nconst bg = PIXI.Sprite.from('https://pixijs.com/assets/bg_rotate.jpg');\n\nbg.anchor.set(0.5);\n\nbg.x = app.screen.width / 2;\nbg.y = app.screen.height / 2;\n\nconst filter = new PIXI.filters.ColorMatrixFilter();\n\nconst container = new PIXI.Container();\n\ncontainer.x = app.screen.width / 2;\ncontainer.y = app.screen.height / 2;\n\nconst bgFront = PIXI.Sprite.from('https://pixijs.com/assets/bg_scene_rotate.jpg');\n\nbgFront.anchor.set(0.5);\n\ncontainer.addChild(bgFront);\n\nconst light2 = PIXI.Sprite.from('https://pixijs.com/assets/light_rotate_2.png');\n\nlight2.anchor.set(0.5);\ncontainer.addChild(light2);\n\nconst light1 = PIXI.Sprite.from('https://pixijs.com/assets/light_rotate_1.png');\n\nlight1.anchor.set(0.5);\ncontainer.addChild(light1);\n\nconst panda = PIXI.Sprite.from('https://pixijs.com/assets/panda.png');\n\npanda.anchor.set(0.5);\n\ncontainer.addChild(panda);\n\napp.stage.addChild(container);\n\napp.stage.filters = [filter];\n\nlet count = 0;\nlet enabled = true;\n\napp.stage.on('pointertap', () =>\n{\n    enabled = !enabled;\n    app.stage.filters = enabled ? [filter] : null;\n});\n\nconst help = new PIXI.Text('Click or tap to turn filters on / off.', {\n    fontFamily: 'Arial',\n    fontSize: 12,\n    fontWeight: 'bold',\n    fill: 'white',\n});\n\nhelp.y = app.screen.height - 25;\nhelp.x = 10;\n\napp.stage.addChild(help);\n\napp.ticker.add((delta) =>\n{\n    bg.rotation += 0.01;\n    bgFront.rotation -= 0.01;\n    light1.rotation += 0.02;\n    light2.rotation += 0.01;\n\n    panda.scale.x = 1 + Math.sin(count) * 0.04;\n    panda.scale.y = 1 + Math.cos(count) * 0.04;\n\n    count += 0.1;\n\n    const { matrix } = filter;\n\n    matrix[1] = Math.sin(count) * 3;\n    matrix[2] = Math.cos(count);\n    matrix[3] = Math.cos(count) * 1.5;\n    matrix[4] = Math.sin(count / 3) * 2;\n    matrix[5] = Math.sin(count / 2);\n    matrix[6] = Math.sin(count / 4);\n});\n",displacementMapCrawlies:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\napp.stage.eventMode = 'static';\n\nconst container = new PIXI.Container();\n\napp.stage.addChild(container);\n\nconst padding = 100;\nconst bounds = new PIXI.Rectangle(\n    -padding,\n    -padding,\n    app.screen.width + padding * 2,\n    app.screen.height + padding * 2,\n);\nconst maggots = [];\n\nfor (let i = 0; i < 20; i++)\n{\n    const maggot = PIXI.Sprite.from('https://pixijs.com/assets/maggot.png');\n\n    maggot.anchor.set(0.5);\n    container.addChild(maggot);\n\n    maggot.direction = Math.random() * Math.PI * 2;\n    maggot.speed = 1;\n    maggot.turnSpeed = Math.random() - 0.8;\n\n    maggot.x = Math.random() * bounds.width;\n    maggot.y = Math.random() * bounds.height;\n\n    maggot.scale.set(1 + Math.random() * 0.3);\n    maggot.original = new PIXI.Point();\n    maggot.original.copyFrom(maggot.scale);\n    maggots.push(maggot);\n}\n\nconst displacementSprite = PIXI.Sprite.from('https://pixijs.com/assets/pixi-filters/displace.png');\nconst displacementFilter = new PIXI.filters.DisplacementFilter(displacementSprite);\n\napp.stage.addChild(displacementSprite);\n\ncontainer.filters = [displacementFilter];\n\ndisplacementFilter.scale.x = 110;\ndisplacementFilter.scale.y = 110;\ndisplacementSprite.anchor.set(0.5);\n\nconst ring = PIXI.Sprite.from('https://pixijs.com/assets/pixi-filters/ring.png');\n\nring.anchor.set(0.5);\n\nring.visible = false;\n\napp.stage.addChild(ring);\n\nconst bg = PIXI.Sprite.from('https://pixijs.com/assets/bg_grass.jpg');\n\nbg.width = app.screen.width;\nbg.height = app.screen.height;\n\nbg.alpha = 0.4;\n\ncontainer.addChild(bg);\n\napp.stage\n    .on('mousemove', onPointerMove)\n    .on('touchmove', onPointerMove);\n\nfunction onPointerMove(eventData)\n{\n    ring.visible = true;\n\n    displacementSprite.position.set(eventData.data.global.x - 25, eventData.data.global.y);\n    ring.position.copyFrom(displacementSprite.position);\n}\n\nlet count = 0;\n\napp.ticker.add(() =>\n{\n    count += 0.05;\n\n    for (let i = 0; i < maggots.length; i++)\n    {\n        const maggot = maggots[i];\n\n        maggot.direction += maggot.turnSpeed * 0.01;\n        maggot.x += Math.sin(maggot.direction) * maggot.speed;\n        maggot.y += Math.cos(maggot.direction) * maggot.speed;\n\n        maggot.rotation = -maggot.direction - Math.PI / 2;\n        maggot.scale.x = maggot.original.x + Math.sin(count) * 0.2;\n\n        // wrap the maggots around as the crawl\n        if (maggot.x < bounds.x)\n        {\n            maggot.x += bounds.width;\n        }\n        else if (maggot.x > bounds.x + bounds.width)\n        {\n            maggot.x -= bounds.width;\n        }\n\n        if (maggot.y < bounds.y)\n        {\n            maggot.y += bounds.height;\n        }\n        else if (maggot.y > bounds.y + bounds.height)\n        {\n            maggot.y -= bounds.height;\n        }\n    }\n});\n",displacementMapFlag:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\napp.stage.eventMode = 'static';\n\nconst container = new PIXI.Container();\n\napp.stage.addChild(container);\n\nconst flag = PIXI.Sprite.from('https://pixijs.com/assets/pixi-filters/flag.png');\n\ncontainer.addChild(flag);\nflag.x = 100;\nflag.y = 100;\n\nconst displacementSprite = PIXI.Sprite.from('https://pixijs.com/assets/pixi-filters/displacement_map_repeat.jpg');\n// Make sure the sprite is wrapping.\n\ndisplacementSprite.texture.baseTexture.wrapMode = PIXI.WRAP_MODES.REPEAT;\nconst displacementFilter = new PIXI.filters.DisplacementFilter(displacementSprite);\n\ndisplacementFilter.padding = 10;\n\ndisplacementSprite.position = flag.position;\n\napp.stage.addChild(displacementSprite);\n\nflag.filters = [displacementFilter];\n\ndisplacementFilter.scale.x = 30;\ndisplacementFilter.scale.y = 60;\n\napp.ticker.add(() =>\n{\n    // Offset the sprite position to make vFilterCoord update to larger value.\n    // Repeat wrapping makes sure there's still pixels on the coordinates.\n    displacementSprite.x++;\n    // Reset x to 0 when it's over width to keep values from going to very huge numbers.\n    if (displacementSprite.x > displacementSprite.width) { displacementSprite.x = 0; }\n});\n"},filtersAdvanced:{custom:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// Create background image\nconst background = PIXI.Sprite.from('https://pixijs.com/assets/bg_grass.jpg');\n\nbackground.width = app.screen.width;\nbackground.height = app.screen.height;\napp.stage.addChild(background);\n\n// Stop application wait for load to finish\napp.stop();\n\nfetch('https://pixijs.com/assets/pixi-filters/shader.frag')\n    .then((res) => res.text())\n    .then(onLoaded);\n\nlet filter;\n\n// Handle the load completed\nfunction onLoaded(data)\n{\n    // Create the new filter, arguments: (vertexShader, framentSource)\n    filter = new PIXI.Filter(null, data, {\n        customUniform: 0.0,\n    });\n\n    // === WARNING ===\n    // specify uniforms in filter constructor\n    // or set them BEFORE first use\n    // filter.uniforms.customUniform = 0.0\n\n    // Add the filter\n    background.filters = [filter];\n\n    // Resume application update\n    app.start();\n}\n\n// Animate the filter\napp.ticker.add((delta) =>\n{\n    filter.uniforms.customUniform += 0.04 * delta;\n});\n",mouseBlending:"import * as PIXI from 'pixi.js';\n\n/**\n * https://github.com/pixijs/pixi.js/wiki/v5-Creating-Filters\n */\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// Create background image\nconst background = PIXI.Sprite.from('https://pixijs.com/assets/bg_grass.jpg');\n\nbackground.width = app.screen.width;\nbackground.height = app.screen.height;\napp.stage.addChild(background);\n\n// NOTE: this shader wont work on old devices where mediump precision is forced in fragment shader\n// because v5 default vertex shader uses `inputSize` in it. Same uniform in fragment and vertex shader\n// cant have different precision :(\n\nconst shaderFrag = `\nprecision highp float;\n\nvarying vec2 vTextureCoord;\n\nuniform vec2 mouse;\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nuniform float time;\n\nvoid main() {\n  vec2 screenPos = vTextureCoord * inputSize.xy + outputFrame.xy;\n  if (length(mouse - screenPos) < 25.0) {\n      gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0) * 0.7; //yellow circle, alpha=0.7\n  } else {\n      // blend with underlying image, alpha=0.5\n      gl_FragColor = vec4( sin(time), (mouse.xy - outputFrame.xy) / outputFrame.zw, 1.0) * 0.5;\n  }\n}\n`;\n\nconst container = new PIXI.Container();\n\ncontainer.filterArea = new PIXI.Rectangle(100, 100, app.screen.width - 200, app.screen.height - 200);\napp.stage.addChild(container);\nconst filter = new PIXI.Filter(null, shaderFrag, {\n    mouse: new PIXI.Point(),\n});\n\ncontainer.filters = [filter];\n\napp.stage.hitArea = app.screen;\napp.stage.eventMode = 'static';\napp.stage.on('pointermove', (event) =>\n{\n    filter.uniforms.mouse.copyFrom(event.global);\n});\n",shaderToyFilterRenderTexture:"import * as PIXI from 'pixi.js';\n\n/**\n * Please note that this is not the most optimal way of doing pure shader generated rendering and should be used when the\n * scene is wanted as input texture. Check the mesh version of example for more performant version if you need only shader\n * generated content.\n **/\nconst app = new PIXI.Application({ background: '#1099bb', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nPIXI.Assets.load('https://pixijs.com/assets/perlin.jpg').then(onAssetsLoaded);\n\nlet filter = null;\n\nconst text = new PIXI.Text('PixiJS', { fill: 0xFFFFFF, fontSize: 80 });\n\ntext.anchor.set(0.5, 0.5);\ntext.position.set(app.renderer.screen.width / 2, app.renderer.screen.height / 2);\n\napp.stage.addChild(text);\n\nlet totalTime = 0;\n\n// Fragment shader, in real use this would be much cleaner when loaded from a file\n// or embedded into the application as data resource.\nconst fragment = `//Based on this: https://www.shadertoy.com/view/wtlSWX\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform sampler2D noise;\nuniform float time;\n// Distance function. Just calculates the height (z) from x,y plane with really simple length check.\n// Its not exact as there could be shorter distances.\nvec2 dist(vec3 p)\n{\n  float id = floor(p.x)+floor(p.y);\n  id = mod(id, 2.);\n  float h = texture2D(noise, vec2(p.x, p.y)*0.04).r*5.1;\n  float h2 = texture2D(uSampler, vTextureCoord).r;\n  return vec2(h+h2-p.z,id);\n}\n//Light calculation.\nvec3 calclight(vec3 p, vec3 rd)\n{\n  vec2 eps = vec2( 0., 0.001);\n  vec3 n = normalize( vec3(\n    dist(p+eps.yxx).x - dist(p-eps.yxx).x,\n    dist(p+eps.xyx).x - dist(p-eps.xyx).x,\n    dist(p+eps.xxy).x - dist(p-eps.xxy).x\n  ));\n\n  vec3 d = vec3( max( 0., dot( -rd ,n)));\n\n  return d;\n}\n\nvoid main()\n{\n  vec2 uv = vec2(vTextureCoord.x, 1.-vTextureCoord.y);\n  uv *=2.;\n  uv-=1.;\n\n  vec3 cam = vec3(0.,time -2., -3.);\n  vec3 target = vec3(sin(time)*0.1, time+cos(time)+2., 0. );\n  float fov = 2.2;\n  vec3 forward = normalize( target - cam);\n  vec3 up = normalize(cross( forward, vec3(0., 1.,0.)));\n  vec3 right = normalize( cross( up, forward));\n  vec3 raydir = normalize(vec3( uv.x *up + uv.y * right + fov*forward));\n\n  //Do the raymarch\n  vec3 col = vec3(0.);\n  float t = 0.;\n  for( int i = 0; i < 100; i++)\n  {\n    vec3 p = t * raydir + cam;\n    vec2 d = dist(p);\n    t+=d.x*0.5;//Jump only half of the distance as height function used is not really the best for heightmaps.\n    if(d.x < 0.001)\n    {\n      vec3 bc = d.y < 0.5 ? vec3(1.0, .8, 0.) :\n                vec3(0.8,0.0, 1.0);\n      col = vec3( 1.) * calclight(p, raydir) * (1. - t/150.) *bc;\n      break;\n    }\n    if(t > 1000.)\n    {\n      break;\n    }\n  }\n  gl_FragColor = vec4(col, 1.);\n}\n`;\n\nfunction onAssetsLoaded(perlin)\n{\n    // Add perlin noise for filter, make sure it's wrapping and does not have mipmap.\n    perlin.baseTexture.wrapMode = PIXI.WRAP_MODES.REPEAT;\n    perlin.baseTexture.mipmap = false;\n\n    // Build the filter\n    filter = new PIXI.Filter(null, fragment, {\n        time: 0.0,\n        noise: perlin,\n    });\n    app.stage.filterArea = app.renderer.screen;\n    app.stage.filters = [filter];\n\n    // Listen for animate update.\n    app.ticker.add((delta) =>\n    {\n        filter.uniforms.time = totalTime;\n        totalTime += delta / 60;\n    });\n}\n"},advanced:{collisionDetection:"import * as PIXI from 'pixi.js';\n\n// Based somewhat on this article by Spicy Yoghurt\n// URL for further reading: https://spicyyoghurt.com/tutorials/html5-javascript-game-development/collision-detection-physics\nconst app = new PIXI.Application({ background: '#111', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// Options for how objects interact\n// How fast the red square moves\nconst movementSpeed = 0.05;\n\n// Strength of the impulse push between two objects\nconst impulsePower = 5;\n\n// Test For Hit\n// A basic AABB check between two different squares\nfunction testForAABB(object1, object2)\n{\n    const bounds1 = object1.getBounds();\n    const bounds2 = object2.getBounds();\n\n    return bounds1.x < bounds2.x + bounds2.width\n        && bounds1.x + bounds1.width > bounds2.x\n        && bounds1.y < bounds2.y + bounds2.height\n        && bounds1.y + bounds1.height > bounds2.y;\n}\n\n// Calculates the results of a collision, allowing us to give an impulse that\n// shoves objects apart\nfunction collisionResponse(object1, object2)\n{\n    if (!object1 || !object2)\n    {\n        return new PIXI.Point(0);\n    }\n\n    const vCollision = new PIXI.Point(\n        object2.x - object1.x,\n        object2.y - object1.y,\n    );\n\n    const distance = Math.sqrt(\n        (object2.x - object1.x) * (object2.x - object1.x)\n        + (object2.y - object1.y) * (object2.y - object1.y),\n    );\n\n    const vCollisionNorm = new PIXI.Point(\n        vCollision.x / distance,\n        vCollision.y / distance,\n    );\n\n    const vRelativeVelocity = new PIXI.Point(\n        object1.acceleration.x - object2.acceleration.x,\n        object1.acceleration.y - object2.acceleration.y,\n    );\n\n    const speed = vRelativeVelocity.x * vCollisionNorm.x\n        + vRelativeVelocity.y * vCollisionNorm.y;\n\n    const impulse = impulsePower * speed / (object1.mass + object2.mass);\n\n    return new PIXI.Point(\n        impulse * vCollisionNorm.x,\n        impulse * vCollisionNorm.y,\n    );\n}\n\n// Calculate the distance between two given points\nfunction distanceBetweenTwoPoints(p1, p2)\n{\n    const a = p1.x - p2.x;\n    const b = p1.y - p2.y;\n\n    return Math.hypot(a, b);\n}\n\n// The green square we will knock about\nconst greenSquare = new PIXI.Sprite(PIXI.Texture.WHITE);\n\ngreenSquare.position.set((app.screen.width - 100) / 2, (app.screen.height - 100) / 2);\ngreenSquare.width = 100;\ngreenSquare.height = 100;\ngreenSquare.tint = 0x00FF00;\ngreenSquare.acceleration = new PIXI.Point(0);\ngreenSquare.mass = 3;\n\n// The square you move around\nconst redSquare = new PIXI.Sprite(PIXI.Texture.WHITE);\n\nredSquare.position.set(0, 0);\nredSquare.width = 100;\nredSquare.height = 100;\nredSquare.tint = 0xFF0000;\nredSquare.acceleration = new PIXI.Point(0);\nredSquare.mass = 1;\n\nconst mouseCoords = { x: 0, y: 0 };\n\napp.stage.eventMode = 'static';\napp.stage.hitArea = app.screen;\napp.stage.on('mousemove', (event) =>\n{\n    mouseCoords.x = event.global.x;\n    mouseCoords.y = event.global.y;\n});\n\n// Listen for animate update\napp.ticker.add((delta) =>\n{\n    // Applied deacceleration for both squares, done by reducing the\n    // acceleration by 0.01% of the acceleration every loop\n    redSquare.acceleration.set(redSquare.acceleration.x * 0.99, redSquare.acceleration.y * 0.99);\n    greenSquare.acceleration.set(greenSquare.acceleration.x * 0.99, greenSquare.acceleration.y * 0.99);\n\n    // Check whether the green square ever moves off the screen\n    // If so, reverse acceleration in that direction\n    if (greenSquare.x < 0 || greenSquare.x > (app.screen.width - 100))\n    {\n        greenSquare.acceleration.x = -greenSquare.acceleration.x;\n    }\n\n    if (greenSquare.y < 0 || greenSquare.y > (app.screen.height - 100))\n    {\n        greenSquare.acceleration.y = -greenSquare.acceleration.y;\n    }\n\n    // If the green square pops out of the cordon, it pops back into the\n    // middle\n    if ((greenSquare.x < -30 || greenSquare.x > (app.screen.width + 30))\n        || greenSquare.y < -30 || greenSquare.y > (app.screen.height + 30))\n    {\n        greenSquare.position.set((app.screen.width - 100) / 2, (app.screen.height - 100) / 2);\n    }\n\n    // If the mouse is off screen, then don't update any further\n    if (app.screen.width > mouseCoords.x || mouseCoords.x > 0\n        || app.screen.height > mouseCoords.y || mouseCoords.y > 0)\n    {\n        // Get the red square's center point\n        const redSquareCenterPosition = new PIXI.Point(\n            redSquare.x + (redSquare.width * 0.5),\n            redSquare.y + (redSquare.height * 0.5),\n        );\n\n        // Calculate the direction vector between the mouse pointer and\n        // the red square\n        const toMouseDirection = new PIXI.Point(\n            mouseCoords.x - redSquareCenterPosition.x,\n            mouseCoords.y - redSquareCenterPosition.y,\n        );\n\n        // Use the above to figure out the angle that direction has\n        const angleToMouse = Math.atan2(\n            toMouseDirection.y,\n            toMouseDirection.x,\n        );\n\n        // Figure out the speed the square should be travelling by, as a\n        // function of how far away from the mouse pointer the red square is\n        const distMouseRedSquare = distanceBetweenTwoPoints(\n            mouseCoords,\n            redSquareCenterPosition,\n        );\n        const redSpeed = distMouseRedSquare * movementSpeed;\n\n        // Calculate the acceleration of the red square\n        redSquare.acceleration.set(\n            Math.cos(angleToMouse) * redSpeed,\n            Math.sin(angleToMouse) * redSpeed,\n        );\n    }\n\n    // If the two squares are colliding\n    if (testForAABB(greenSquare, redSquare))\n    {\n        // Calculate the changes in acceleration that should be made between\n        // each square as a result of the collision\n        const collisionPush = collisionResponse(greenSquare, redSquare);\n        // Set the changes in acceleration for both squares\n\n        redSquare.acceleration.set(\n            (collisionPush.x * greenSquare.mass),\n            (collisionPush.y * greenSquare.mass),\n        );\n        greenSquare.acceleration.set(\n            -(collisionPush.x * redSquare.mass),\n            -(collisionPush.y * redSquare.mass),\n        );\n    }\n\n    greenSquare.x += greenSquare.acceleration.x * delta;\n    greenSquare.y += greenSquare.acceleration.y * delta;\n\n    redSquare.x += redSquare.acceleration.x * delta;\n    redSquare.y += redSquare.acceleration.y * delta;\n});\n\n// Add to stage\napp.stage.addChild(redSquare, greenSquare);\n",mouseTrail:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ background: '#1099bb', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// Get the texture for rope.\nconst trailTexture = PIXI.Texture.from('https://pixijs.com/assets/trail.png');\nconst historyX = [];\nconst historyY = [];\n// historySize determines how long the trail will be.\nconst historySize = 20;\n// ropeSize determines how smooth the trail will be.\nconst ropeSize = 100;\nconst points = [];\n\n// Create history array.\nfor (let i = 0; i < historySize; i++)\n{\n    historyX.push(0);\n    historyY.push(0);\n}\n// Create rope points.\nfor (let i = 0; i < ropeSize; i++)\n{\n    points.push(new PIXI.Point(0, 0));\n}\n\n// Create the rope\nconst rope = new PIXI.SimpleRope(trailTexture, points);\n\n// Set the blendmode\nrope.blendmode = PIXI.BLEND_MODES.ADD;\n\napp.stage.addChild(rope);\n\nlet mouseposition = null;\n\napp.stage.eventMode = 'static';\napp.stage.hitArea = app.screen;\napp.stage.on('mousemove', (event) =>\n{\n    mouseposition = mouseposition || { x: 0, y: 0 };\n    mouseposition.x = event.global.x;\n    mouseposition.y = event.global.y;\n});\n\n// Listen for animate update\napp.ticker.add(() =>\n{\n    if (!mouseposition) return;\n\n    // Update the mouse values to history\n    historyX.pop();\n    historyX.unshift(mouseposition.x);\n    historyY.pop();\n    historyY.unshift(mouseposition.y);\n    // Update the points to correspond with history.\n    for (let i = 0; i < ropeSize; i++)\n    {\n        const p = points[i];\n\n        // Smooth the curve with cubic interpolation to prevent sharp edges.\n        const ix = cubicInterpolation(historyX, i / ropeSize * historySize);\n        const iy = cubicInterpolation(historyY, i / ropeSize * historySize);\n\n        p.x = ix;\n        p.y = iy;\n    }\n});\n\n/**\n * Cubic interpolation based on https://github.com/osuushi/Smooth.js\n */\nfunction clipInput(k, arr)\n{\n    if (k < 0) k = 0;\n    if (k > arr.length - 1) k = arr.length - 1;\n\n    return arr[k];\n}\n\nfunction getTangent(k, factor, array)\n{\n    return factor * (clipInput(k + 1, array) - clipInput(k - 1, array)) / 2;\n}\n\nfunction cubicInterpolation(array, t, tangentFactor)\n{\n    if (tangentFactor === null) tangentFactor = 1;\n\n    const k = Math.floor(t);\n    const m = [getTangent(k, tangentFactor, array), getTangent(k + 1, tangentFactor, array)];\n    const p = [clipInput(k, array), clipInput(k + 1, array)];\n\n    t -= k;\n    const t2 = t * t;\n    const t3 = t * t2;\n\n    return (2 * t3 - 3 * t2 + 1) * p[0] + (t3 - 2 * t2 + t) * m[0] + (-2 * t3 + 3 * t2) * p[1] + (t3 - t2) * m[1];\n}\n",scratchCard:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// prepare circle texture, that will be our brush\nconst brush = new PIXI.Graphics()\n    .beginFill(0xffffff)\n    .drawCircle(0, 0, 50);\n\n// Create a line that will interpolate the drawn points\nconst line = new PIXI.Graphics();\n\nPIXI.Assets.add('t1', 'https://pixijs.com/assets/bg_grass.jpg');\nPIXI.Assets.add('t2', 'https://pixijs.com/assets/bg_rotate.jpg');\nPIXI.Assets.load(['t1', 't2']).then(setup);\n\nfunction setup()\n{\n    const { width, height } = app.screen;\n    const stageSize = { width, height };\n\n    const background = Object.assign(PIXI.Sprite.from('t1'), stageSize);\n    const imageToReveal = Object.assign(PIXI.Sprite.from('t2'), stageSize);\n    const renderTexture = PIXI.RenderTexture.create(stageSize);\n    const renderTextureSprite = new PIXI.Sprite(renderTexture);\n\n    imageToReveal.mask = renderTextureSprite;\n\n    app.stage.addChild(\n        background,\n        imageToReveal,\n        renderTextureSprite,\n    );\n\n    app.stage.eventMode = 'static';\n    app.stage.hitArea = app.screen;\n    app.stage\n        .on('pointerdown', pointerDown)\n        .on('pointerup', pointerUp)\n        .on('pointerupoutside', pointerUp)\n        .on('pointermove', pointerMove);\n\n    let dragging = false;\n    let lastDrawnPoint = null;\n\n    function pointerMove({ global: { x, y } })\n    {\n        if (dragging)\n        {\n            brush.position.set(x, y);\n            app.renderer.render(brush, {\n                renderTexture,\n                clear: false,\n                skipUpdateTransform: false,\n            });\n            // Smooth out the drawing a little bit to make it look nicer\n            // this connects the previous drawn point to the current one\n            // using a line\n            if (lastDrawnPoint)\n            {\n                line\n                    .clear()\n                    .lineStyle({ width: 100, color: 0xffffff })\n                    .moveTo(lastDrawnPoint.x, lastDrawnPoint.y)\n                    .lineTo(x, y);\n                app.renderer.render(line, {\n                    renderTexture,\n                    clear: false,\n                    skipUpdateTransform: false,\n                });\n            }\n            lastDrawnPoint = lastDrawnPoint || new PIXI.Point();\n            lastDrawnPoint.set(x, y);\n        }\n    }\n\n    function pointerDown(event)\n    {\n        dragging = true;\n        pointerMove(event);\n    }\n\n    function pointerUp(event)\n    {\n        dragging = false;\n        lastDrawnPoint = null;\n    }\n}\n",screenShot:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ backgroundColor: '#111', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nconst texture = PIXI.Texture.from('https://pixijs.com/assets/bunny.png');\nconst bunnyContainer = new PIXI.Container();\n\nasync function takeScreenshot()\n{\n    app.stop();\n    const url = await app.renderer.extract.base64(bunnyContainer);\n    const a = document.createElement('a');\n\n    document.body.append(a);\n    a.download = 'screenshot';\n    a.href = url;\n    a.click();\n    a.remove();\n    app.start();\n}\n\napp.stage.eventMode = 'static';\napp.stage.hitArea = app.screen;\napp.stage.on('pointerdown', takeScreenshot);\n\nfor (let i = 0; i < 25; i++)\n{\n    const bunny = new PIXI.Sprite(texture);\n\n    bunny.anchor.set(0.5);\n    bunny.x = (i % 5) * 40;\n    bunny.y = Math.floor(i / 5) * 40;\n    bunnyContainer.addChild(bunny);\n}\n\nbunnyContainer.x = 400;\nbunnyContainer.y = 300;\nbunnyContainer.pivot.x = bunnyContainer.width / 2;\nbunnyContainer.pivot.y = bunnyContainer.height / 2;\n\napp.ticker.add((delta) =>\n{\n    bunnyContainer.rotation += 0.01 * delta;\n});\n\nconst style = new PIXI.TextStyle({\n    fontFamily: 'Roboto',\n    fill: '#999',\n});\n\nconst screenshotText = new PIXI.Text('Click To Take Screenshot', style);\n\nscreenshotText.x = Math.round((app.screen.width - screenshotText.width) / 2);\nscreenshotText.y = Math.round(screenshotText.height / 2);\n\napp.stage.addChild(screenshotText, bunnyContainer);\n",slots:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ background: '#1099bb', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nPIXI.Assets.load([\n    'https://pixijs.com/assets/eggHead.png',\n    'https://pixijs.com/assets/flowerTop.png',\n    'https://pixijs.com/assets/helmlok.png',\n    'https://pixijs.com/assets/skully.png',\n]).then(onAssetsLoaded);\n\nconst REEL_WIDTH = 160;\nconst SYMBOL_SIZE = 150;\n\n// onAssetsLoaded handler builds the example.\nfunction onAssetsLoaded()\n{\n    // Create different slot symbols.\n    const slotTextures = [\n        PIXI.Texture.from('https://pixijs.com/assets/eggHead.png'),\n        PIXI.Texture.from('https://pixijs.com/assets/flowerTop.png'),\n        PIXI.Texture.from('https://pixijs.com/assets/helmlok.png'),\n        PIXI.Texture.from('https://pixijs.com/assets/skully.png'),\n    ];\n\n    // Build the reels\n    const reels = [];\n    const reelContainer = new PIXI.Container();\n\n    for (let i = 0; i < 5; i++)\n    {\n        const rc = new PIXI.Container();\n\n        rc.x = i * REEL_WIDTH;\n        reelContainer.addChild(rc);\n\n        const reel = {\n            container: rc,\n            symbols: [],\n            position: 0,\n            previousPosition: 0,\n            blur: new PIXI.filters.BlurFilter(),\n        };\n\n        reel.blur.blurX = 0;\n        reel.blur.blurY = 0;\n        rc.filters = [reel.blur];\n\n        // Build the symbols\n        for (let j = 0; j < 4; j++)\n        {\n            const symbol = new PIXI.Sprite(slotTextures[Math.floor(Math.random() * slotTextures.length)]);\n            // Scale the symbol to fit symbol area.\n\n            symbol.y = j * SYMBOL_SIZE;\n            symbol.scale.x = symbol.scale.y = Math.min(SYMBOL_SIZE / symbol.width, SYMBOL_SIZE / symbol.height);\n            symbol.x = Math.round((SYMBOL_SIZE - symbol.width) / 2);\n            reel.symbols.push(symbol);\n            rc.addChild(symbol);\n        }\n        reels.push(reel);\n    }\n    app.stage.addChild(reelContainer);\n\n    // Build top & bottom covers and position reelContainer\n    const margin = (app.screen.height - SYMBOL_SIZE * 3) / 2;\n\n    reelContainer.y = margin;\n    reelContainer.x = Math.round(app.screen.width - REEL_WIDTH * 5);\n    const top = new PIXI.Graphics();\n\n    top.beginFill(0, 1);\n    top.drawRect(0, 0, app.screen.width, margin);\n    const bottom = new PIXI.Graphics();\n\n    bottom.beginFill(0, 1);\n    bottom.drawRect(0, SYMBOL_SIZE * 3 + margin, app.screen.width, margin);\n\n    // Add play text\n    const style = new PIXI.TextStyle({\n        fontFamily: 'Arial',\n        fontSize: 36,\n        fontStyle: 'italic',\n        fontWeight: 'bold',\n        fill: ['#ffffff', '#00ff99'], // gradient\n        stroke: '#4a1850',\n        strokeThickness: 5,\n        dropShadow: true,\n        dropShadowColor: '#000000',\n        dropShadowBlur: 4,\n        dropShadowAngle: Math.PI / 6,\n        dropShadowDistance: 6,\n        wordWrap: true,\n        wordWrapWidth: 440,\n    });\n\n    const playText = new PIXI.Text('Spin the wheels!', style);\n\n    playText.x = Math.round((bottom.width - playText.width) / 2);\n    playText.y = app.screen.height - margin + Math.round((margin - playText.height) / 2);\n    bottom.addChild(playText);\n\n    // Add header text\n    const headerText = new PIXI.Text('PIXI MONSTER SLOTS!', style);\n\n    headerText.x = Math.round((top.width - headerText.width) / 2);\n    headerText.y = Math.round((margin - headerText.height) / 2);\n    top.addChild(headerText);\n\n    app.stage.addChild(top);\n    app.stage.addChild(bottom);\n\n    // Set the interactivity.\n    bottom.eventMode = 'static';\n    bottom.cursor = 'pointer';\n    bottom.addListener('pointerdown', () =>\n    {\n        startPlay();\n    });\n\n    let running = false;\n\n    // Function to start playing.\n    function startPlay()\n    {\n        if (running) return;\n        running = true;\n\n        for (let i = 0; i < reels.length; i++)\n        {\n            const r = reels[i];\n            const extra = Math.floor(Math.random() * 3);\n            const target = r.position + 10 + i * 5 + extra;\n            const time = 2500 + i * 600 + extra * 600;\n\n            tweenTo(r, 'position', target, time, backout(0.5), null, i === reels.length - 1 ? reelsComplete : null);\n        }\n    }\n\n    // Reels done handler.\n    function reelsComplete()\n    {\n        running = false;\n    }\n\n    // Listen for animate update.\n    app.ticker.add((delta) =>\n    {\n    // Update the slots.\n        for (let i = 0; i < reels.length; i++)\n        {\n            const r = reels[i];\n            // Update blur filter y amount based on speed.\n            // This would be better if calculated with time in mind also. Now blur depends on frame rate.\n\n            r.blur.blurY = (r.position - r.previousPosition) * 8;\n            r.previousPosition = r.position;\n\n            // Update symbol positions on reel.\n            for (let j = 0; j < r.symbols.length; j++)\n            {\n                const s = r.symbols[j];\n                const prevy = s.y;\n\n                s.y = ((r.position + j) % r.symbols.length) * SYMBOL_SIZE - SYMBOL_SIZE;\n                if (s.y < 0 && prevy > SYMBOL_SIZE)\n                {\n                    // Detect going over and swap a texture.\n                    // This should in proper product be determined from some logical reel.\n                    s.texture = slotTextures[Math.floor(Math.random() * slotTextures.length)];\n                    s.scale.x = s.scale.y = Math.min(SYMBOL_SIZE / s.texture.width, SYMBOL_SIZE / s.texture.height);\n                    s.x = Math.round((SYMBOL_SIZE - s.width) / 2);\n                }\n            }\n        }\n    });\n}\n\n// Very simple tweening utility function. This should be replaced with a proper tweening library in a real product.\nconst tweening = [];\n\nfunction tweenTo(object, property, target, time, easing, onchange, oncomplete)\n{\n    const tween = {\n        object,\n        property,\n        propertyBeginValue: object[property],\n        target,\n        easing,\n        time,\n        change: onchange,\n        complete: oncomplete,\n        start: Date.now(),\n    };\n\n    tweening.push(tween);\n\n    return tween;\n}\n// Listen for animate update.\napp.ticker.add((delta) =>\n{\n    const now = Date.now();\n    const remove = [];\n\n    for (let i = 0; i < tweening.length; i++)\n    {\n        const t = tweening[i];\n        const phase = Math.min(1, (now - t.start) / t.time);\n\n        t.object[t.property] = lerp(t.propertyBeginValue, t.target, t.easing(phase));\n        if (t.change) t.change(t);\n        if (phase === 1)\n        {\n            t.object[t.property] = t.target;\n            if (t.complete) t.complete(t);\n            remove.push(t);\n        }\n    }\n    for (let i = 0; i < remove.length; i++)\n    {\n        tweening.splice(tweening.indexOf(remove[i]), 1);\n    }\n});\n\n// Basic lerp funtion.\nfunction lerp(a1, a2, t)\n{\n    return a1 * (1 - t) + a2 * t;\n}\n\n// Backout function from tweenjs.\n// https://github.com/CreateJS/TweenJS/blob/master/src/tweenjs/Ease.js\nfunction backout(amount)\n{\n    return (t) => (--t * t * ((amount + 1) * t + amount) + 1);\n}\n",spinners:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ background: '#1099bb', resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n/* ---------------------------------------\n Spinner 1. Square with radial completion.\n -------------------------------------- */\nconst generateSpinner1 = (position) =>\n{\n    const container = new PIXI.Container();\n\n    container.position = position;\n    app.stage.addChild(container);\n\n    const base = PIXI.Sprite.from('https://pixijs.com/assets/bg_scene_rotate.jpg');\n    const size = 100;\n\n    base.width = size;\n    base.height = size;\n\n    const bottom = PIXI.Sprite.from('https://pixijs.com/assets/bg_rotate.jpg');\n\n    bottom.width = size;\n    bottom.height = size;\n\n    const mask = new PIXI.Graphics();\n\n    mask.position.set(size / 2, size / 2);\n    base.mask = mask;\n    window.mask = mask;\n\n    container.addChild(bottom);\n    container.addChild(base);\n    container.addChild(mask);\n\n    let phase = 0;\n\n    return (delta) =>\n    {\n        // Update phase\n        phase += delta / 60;\n        phase %= (Math.PI * 2);\n\n        // Calculate target point.\n        const x = Math.cos(phase - Math.PI / 2) * size;\n        const y = Math.sin(phase - Math.PI / 2) * size;\n\n        const segments = [\n            [-size / 2, -size / 2, size / 2, -size / 2], // top segment\n            [size / 2, -size / 2, size / 2, size / 2], // right\n            [-size / 2, size / 2, size / 2, size / 2], // bottom\n            [-size / 2, -size / 2, -size / 2, size / 2], // left\n        ];\n\n        // Find the intersecting segment.\n        let intersection = null;\n        let winding = 0;\n\n        for (let i = 0; i < segments.length; i++)\n        {\n            const segment = segments[i];\n            const hit = intersect(0, 0, x, y, segment[0], segment[1], segment[2], segment[3]);\n\n            if (hit)\n            {\n                intersection = hit;\n                if (i === 0) winding = hit.x > 0 ? 0 : 4;\n                else winding = i;\n                break;\n            }\n        }\n\n        const corners = [\n            size / 2, -size / 2, // Top right\n            size / 2, size / 2, // Bottom right\n            -size / 2, size / 2, // Bottom left\n            -size / 2, -size / 2, // Top left,\n            0, -size / 2, // End point\n        ];\n\n        // Redraw mask\n        mask.clear();\n        mask.lineStyle(2, 0xff0000, 1);\n        mask.beginFill(0xff0000, 1);\n        mask.moveTo(0, -size / 2);\n        mask.lineTo(0, 0);\n\n        mask.lineTo(intersection.x, intersection.y);\n\n        // fill the corners\n        for (let i = winding; i < corners.length / 2; i++)\n        {\n            mask.lineTo(corners[i * 2], corners[i * 2 + 1]);\n        }\n        mask.endFill();\n    };\n};\n\n/* -----------------------\n Spinner 2. Scaling balls.\n ---------------------- */\nconst generateSpinner2 = (position) =>\n{\n    const container = new PIXI.Container();\n\n    container.position = position;\n    app.stage.addChild(container);\n\n    const size = 100;\n    const ballAmount = 7;\n    const balls = [];\n\n    for (let i = 0; i < ballAmount; i++)\n    {\n        const ball = PIXI.Sprite.from('https://pixijs.com/assets/circle.png');\n\n        ball.anchor.set(0.5);\n        container.addChild(ball);\n        ball.position.set(\n            size / 2 + Math.cos(i / ballAmount * Math.PI * 2) * size / 3,\n            size / 2 + Math.sin(i / ballAmount * Math.PI * 2) * size / 3,\n        );\n        balls.push(ball);\n    }\n\n    let phase = 0;\n\n    return (delta) =>\n    {\n        // Update phase\n        phase += delta / 60;\n        phase %= (Math.PI * 2);\n\n        // Update ball scales\n        balls.forEach((b, i) =>\n        {\n            const sin = Math.sin(i / ballAmount * Math.PI - phase);\n            // Multiply sin with itself to get more steeper edge.\n\n            b.scale.set(Math.abs(sin * sin * sin * 0.5) + 0.5);\n        });\n    };\n};\n\n/* ---------------------\n Spinner 3. Radial mask.\n -------------------- */\nconst generateSpinner3 = (position) =>\n{\n    const container = new PIXI.Container();\n\n    container.position = position;\n    app.stage.addChild(container);\n\n    const base = PIXI.Sprite.from('https://pixijs.com/assets/bg_scene_rotate.jpg');\n    const size = 100;\n\n    base.width = size;\n    base.height = size;\n\n    const mask = new PIXI.Graphics();\n\n    mask.position.set(size / 2, size / 2);\n    base.mask = mask;\n    window.mask = mask;\n\n    container.addChild(base);\n    container.addChild(mask);\n\n    let phase = 0;\n\n    return (delta) =>\n    {\n        // Update phase\n        phase += delta / 60;\n        phase %= (Math.PI * 2);\n\n        const angleStart = 0 - Math.PI / 2;\n        const angle = phase + angleStart;\n        const radius = 50;\n\n        const x1 = Math.cos(angleStart) * radius;\n        const y1 = Math.sin(angleStart) * radius;\n\n        // Redraw mask\n        mask.clear();\n        mask.lineStyle(2, 0xff0000, 1);\n        mask.beginFill(0xff0000, 1);\n        mask.moveTo(0, 0);\n        mask.lineTo(x1, y1);\n        mask.arc(0, 0, radius, angleStart, angle, false);\n        mask.lineTo(0, 0);\n        mask.endFill();\n    };\n};\n\n/* ---------------------------------\n Spinner 4. Rounded rectangle edges.\n ------------------------------- */\nconst generateSpinner4 = (position) =>\n{\n    const container = new PIXI.Container();\n\n    container.position = position;\n    app.stage.addChild(container);\n\n    const size = 100;\n    const arcRadius = 15;\n\n    const base = PIXI.Sprite.from('https://pixijs.com/assets/bg_scene_rotate.jpg');\n\n    base.width = size;\n    base.height = size;\n\n    // For better performance having assets prerounded would be better than masking.\n    const roundingMask = new PIXI.Graphics();\n\n    roundingMask.beginFill(0, 1);\n    roundingMask.lineStyle(1, 0xff0000, 1);\n    roundingMask.drawRoundedRect(0, 0, size, size, arcRadius);\n    roundingMask.endFill();\n    base.mask = roundingMask;\n\n    // The edge could be replaced with image as well.\n    const lineSize = 5;\n    const edge = new PIXI.Graphics();\n\n    edge.lineStyle(lineSize, 0xff0000, 1);\n    edge.drawRoundedRect(0, 0, size, size, arcRadius);\n    edge.endFill();\n\n    // Mask in this example works basically the same way as in example 1.\n    // Except it is reversed and calculates the mask in straight lines in edges.\n    const mask = new PIXI.Graphics();\n\n    mask.position.set(size / 2, size / 2);\n    edge.mask = mask;\n\n    container.addChild(base);\n    container.addChild(roundingMask);\n    container.addChild(edge);\n    container.addChild(mask);\n\n    let phase = 0;\n\n    return (delta) =>\n    {\n        // Update phase\n        phase += delta / 160;\n        phase %= (Math.PI * 2);\n\n        // Calculate target point.\n        const x = Math.cos(phase - Math.PI / 2) * size;\n        const y = Math.sin(phase - Math.PI / 2) * size;\n        // Line segments\n        const segments = [\n            [-size / 2 + lineSize, -size / 2 + lineSize, size / 2 - lineSize, -size / 2 + lineSize], // top segment\n            [size / 2 - lineSize, -size / 2 + lineSize, size / 2 - lineSize, size / 2 - lineSize], // right\n            [-size / 2 + lineSize, size / 2 - lineSize, size / 2 - lineSize, size / 2 - lineSize], // bottom\n            [-size / 2 + lineSize, -size / 2 + lineSize, -size / 2 + lineSize, size / 2 - lineSize], // left\n        ];\n        // To which dir should mask continue at each segment\n        let outDir = [\n            [0, -1],\n            [1, 0],\n            [0, 1],\n            [-1, 0],\n        ];\n\n        // Find the intersecting segment.\n        let intersection = null;\n        let winding = 0;\n        // What direction should the line continue after hit has been found before hitting the line size\n\n        for (let i = 0; i < segments.length; i++)\n        {\n            const segment = segments[i];\n            const hit = intersect(0, 0, x, y, segment[0], segment[1], segment[2], segment[3]);\n\n            if (hit)\n            {\n                intersection = hit;\n                if (i === 0) winding = hit.x < 0 ? 0 : 4;\n                else winding = 4 - i;\n                outDir = outDir[i];\n                break;\n            }\n        }\n\n        const corners = [\n            -size / 2 - lineSize, -size / 2 - lineSize, // Top left,\n            -size / 2 - lineSize, size / 2 + lineSize, // Bottom left\n            size / 2 + lineSize, size / 2 + lineSize, // Bottom right\n            size / 2 + lineSize, -size / 2 - lineSize, // Top right\n        ];\n\n        // Redraw mask\n        mask.clear();\n        mask.lineStyle(2, 0x00ff00, 1);\n        mask.beginFill(0xff0000, 1);\n\n        mask.moveTo(0, 0);\n        mask.moveTo(0, -size / 2 - lineSize);\n\n        // fill the corners\n        for (let i = 0; i < winding; i++)\n        {\n            mask.lineTo(corners[i * 2], corners[i * 2 + 1]);\n        }\n\n        mask.lineTo(intersection.x + outDir[0] * lineSize * 2, intersection.y + outDir[1] * lineSize * 2);\n        mask.lineTo(intersection.x, intersection.y);\n        mask.lineTo(0, 0);\n\n        mask.endFill();\n    };\n};\n\n/* ---------------------\n Spinner 5. Rounded rectangle fixed length spinner by jonlepage\n -------------------- */\nconst generateSpinner5 = (position) =>\n{\n    const container = new PIXI.Container();\n\n    container.position = position;\n    app.stage.addChild(container);\n\n    const halfCircle = new PIXI.Graphics();\n\n    halfCircle.beginFill(0xff0000);\n    halfCircle.lineStyle(2, 0xffffff);\n    halfCircle.arc(0, 0, 100, 0, Math.PI);\n    halfCircle.endFill();\n    halfCircle.position.set(50, 50);\n\n    const rectangle = new PIXI.Graphics();\n\n    rectangle.lineStyle(2, 0xffffff, 1);\n    rectangle.drawRoundedRect(0, 0, 100, 100, 16);\n    rectangle.endFill();\n    rectangle.mask = halfCircle;\n\n    container.addChild(rectangle);\n    container.addChild(halfCircle);\n\n    let phase = 0;\n\n    return (delta) =>\n    {\n        // Update phase\n        phase += delta / 6;\n        phase %= (Math.PI * 2);\n\n        halfCircle.rotation = phase;\n    };\n};\n\nconst onTick = [\n    generateSpinner1(new PIXI.Point(50, 50)),\n    generateSpinner2(new PIXI.Point(160, 50)),\n    generateSpinner3(new PIXI.Point(270, 50)),\n    generateSpinner4(new PIXI.Point(380, 50)),\n    generateSpinner5(new PIXI.Point(490, 50)),\n];\n\n// Listen for animate update\napp.ticker.add((delta) =>\n{\n    // Call tick handling for each spinner.\n    onTick.forEach((cb) =>\n    {\n        cb(delta);\n    });\n});\n\n/**\n * Helper functions\n\n    line intercept math by Paul Bourke http://paulbourke.net/geometry/pointlineplane/\n    Determine the intersection point of two line segments\n    Return FALSE if the lines don't intersect\n\n    Code modified from original to match pixi examples linting rules.\n*/\nfunction intersect(x1, y1, x2, y2, x3, y3, x4, y4)\n{\n    // Check if none of the lines are of length 0\n    if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4))\n    {\n        return false;\n    }\n\n    const denominator = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));\n\n    // Lines are parallel\n    if (denominator === 0)\n    {\n        return false;\n    }\n\n    const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;\n    const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;\n\n    // is the intersection along the segments\n    if (ua < 0 || ua > 1 || ub < 0 || ub > 1)\n    {\n        return false;\n    }\n\n    // Return a object with the x and y coordinates of the intersection\n    const x = x1 + ua * (x2 - x1);\n    const y = y1 + ua * (y2 - y1);\n\n    return { x, y };\n}\n",starWarp:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// Get the texture for star.\nconst starTexture = PIXI.Texture.from('https://pixijs.com/assets/star.png');\n\nconst starAmount = 1000;\nlet cameraZ = 0;\nconst fov = 20;\nconst baseSpeed = 0.025;\nlet speed = 0;\nlet warpSpeed = 0;\nconst starStretch = 5;\nconst starBaseSize = 0.05;\n\n// Create the stars\nconst stars = [];\n\nfor (let i = 0; i < starAmount; i++)\n{\n    const star = {\n        sprite: new PIXI.Sprite(starTexture),\n        z: 0,\n        x: 0,\n        y: 0,\n    };\n\n    star.sprite.anchor.x = 0.5;\n    star.sprite.anchor.y = 0.7;\n    randomizeStar(star, true);\n    app.stage.addChild(star.sprite);\n    stars.push(star);\n}\n\nfunction randomizeStar(star, initial)\n{\n    star.z = initial ? Math.random() * 2000 : cameraZ + Math.random() * 1000 + 2000;\n\n    // Calculate star positions with radial random coordinate so no star hits the camera.\n    const deg = Math.random() * Math.PI * 2;\n    const distance = Math.random() * 50 + 1;\n\n    star.x = Math.cos(deg) * distance;\n    star.y = Math.sin(deg) * distance;\n}\n\n// Change flight speed every 5 seconds\nsetInterval(() =>\n{\n    warpSpeed = warpSpeed > 0 ? 0 : 1;\n}, 5000);\n\n// Listen for animate update\napp.ticker.add((delta) =>\n{\n    // Simple easing. This should be changed to proper easing function when used for real.\n    speed += (warpSpeed - speed) / 20;\n    cameraZ += delta * 10 * (speed + baseSpeed);\n    for (let i = 0; i < starAmount; i++)\n    {\n        const star = stars[i];\n\n        if (star.z < cameraZ) randomizeStar(star);\n\n        // Map star 3d position to 2d with really simple projection\n        const z = star.z - cameraZ;\n\n        star.sprite.x = star.x * (fov / z) * app.renderer.screen.width + app.renderer.screen.width / 2;\n        star.sprite.y = star.y * (fov / z) * app.renderer.screen.width + app.renderer.screen.height / 2;\n\n        // Calculate star scale & rotation.\n        const dxCenter = star.sprite.x - app.renderer.screen.width / 2;\n        const dyCenter = star.sprite.y - app.renderer.screen.height / 2;\n        const distanceCenter = Math.sqrt(dxCenter * dxCenter + dyCenter * dyCenter);\n        const distanceScale = Math.max(0, (2000 - z) / 2000);\n\n        star.sprite.scale.x = distanceScale * starBaseSize;\n        // Star is looking towards center so that y axis is towards center.\n        // Scale the star depending on how fast we are moving, what the stretchfactor is\n        // and depending on how far away it is from the center.\n        star.sprite.scale.y = distanceScale * starBaseSize\n            + distanceScale * speed * starStretch * distanceCenter / app.renderer.screen.width;\n        star.sprite.rotation = Math.atan2(dyCenter, dxCenter) + Math.PI / 2;\n    }\n});\n"},meshAndShaders:{instancedGeometry:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nconst geometry = new PIXI.Geometry()\n    .addAttribute('aVPos', [-100, 0, 100, 0, 0, -150]);\n\ngeometry.instanced = true;\ngeometry.instanceCount = 5;\n\nconst positionSize = 2;\nconst colorSize = 3;\nconst buffer = new PIXI.Buffer(new Float32Array(geometry.instanceCount * (positionSize + colorSize)));\n\ngeometry.addAttribute(\n    'aIPos',\n    buffer,\n    positionSize,\n    false,\n    PIXI.TYPES.FLOAT,\n    4 * (positionSize + colorSize),\n    0,\n    true\n);\ngeometry.addAttribute(\n    'aICol',\n    buffer,\n    colorSize,\n    false,\n    PIXI.TYPES.FLOAT,\n    4 * (positionSize + colorSize),\n    4 * positionSize, true\n);\n\nfor (let i = 0; i < geometry.instanceCount; i++)\n{\n    const instanceOffset = i * (positionSize + colorSize);\n\n    buffer.data[instanceOffset + 0] = i * 80;\n    buffer.data[instanceOffset + 2] = Math.random();\n    buffer.data[instanceOffset + 3] = Math.random();\n    buffer.data[instanceOffset + 4] = Math.random();\n}\n\nconst shader = PIXI.Shader.from(`\n    precision mediump float;\n    attribute vec2 aVPos;\n    attribute vec2 aIPos;\n    attribute vec3 aICol;\n\n    uniform mat3 translationMatrix;\n    uniform mat3 projectionMatrix;\n\n    varying vec3 vCol;\n\n    void main() {\n        vCol = aICol;\n\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVPos + aIPos, 1.0)).xy, 0.0, 1.0);\n    }`,\n\n`precision mediump float;\n\n    varying vec3 vCol;\n\n    void main() {\n        gl_FragColor = vec4(vCol, 1.0);\n    }\n\n`);\n\nconst triangles = new PIXI.Mesh(geometry, shader);\n\ntriangles.position.set(400, 300);\n\napp.stage.addChild(triangles);\n\napp.ticker.add((delta) =>\n{\n    triangles.rotation += 0.01;\n});\n",interleavingGeometry:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nconst geometry = new PIXI.Geometry()\n    .addAttribute('aVertexPosition', // the attribute name\n        [-100, -100, // x, y\n            100, -100, // x, y\n            100, 100,\n            -100, 100], // x, y\n        2) // the size of the attribute\n    .addAttribute('aUvs', // the attribute name\n        [0, 0, // u, v\n            1, 0, // u, v\n            1, 1,\n            0, 1], // u, v\n        2) // the size of the attribute\n    .addIndex([0, 1, 2, 0, 2, 3])\n    .interleave();\n\nconst shader = PIXI.Shader.from(`\n\n    precision mediump float;\n\n    attribute vec2 aVertexPosition;\n    attribute vec2 aUvs;\n\n    uniform mat3 translationMatrix;\n    uniform mat3 projectionMatrix;\n\n    varying vec2 vUvs;\n\n    void main() {\n\n        vUvs = aUvs;\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    }`,\n\n`precision mediump float;\n\n    varying vec2 vUvs;\n\n    uniform sampler2D uSampler2;\n\n    void main() {\n\n        gl_FragColor = texture2D(uSampler2, vUvs );\n    }\n\n`,\n{\n    uSampler2: PIXI.Texture.from('https://pixijs.com/assets/bg_scene_rotate.jpg'),\n});\n\nconst quad = new PIXI.Mesh(geometry, shader);\n\nquad.position.set(400, 300);\nquad.scale.set(2);\n\napp.stage.addChild(quad);\n\napp.ticker.add((delta) =>\n{\n    quad.rotation += 0.01;\n});\n",mergingGeometry:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nconst geometry = new PIXI.Geometry()\n    .addAttribute('aVertexPosition', // the attribute name\n        [-100, -100, // x, y\n            100, -100, // x, y\n            100, 100,\n            -100, 100], // x, y\n        2) // the size of the attribute\n    .addAttribute('aUvs', // the attribute name\n        [0, 0, // u, v\n            1, 0, // u, v\n            1, 1,\n            0, 1], // u, v\n        2) // the size of the attribute\n    .addIndex([0, 1, 2, 0, 2, 3]);\n\nconst geometry2 = new PIXI.Geometry()\n    .addAttribute('aVertexPosition', // the attribute name\n        [-100 + 100, -100, // x, y\n            100 + 100, -100, // x, y\n            100 + 100, 100], // x, y\n        2) // the size of the attribute\n    .addAttribute('aUvs', // the attribute name\n        [0, 0, // u, v\n            1, 0, // u, v\n            1, 1], // u, v\n        2) // the size of the attribute\n    .addIndex([0, 1, 2]);\n\nconst geometry3 = PIXI.Geometry.merge([geometry, geometry2]);\n\nconst shader = PIXI.Shader.from(`\n\n    precision mediump float;\n\n    attribute vec2 aVertexPosition;\n    attribute vec2 aUvs;\n\n    uniform mat3 translationMatrix;\n    uniform mat3 projectionMatrix;\n\n    varying vec2 vUvs;\n\n    void main() {\n\n        vUvs = aUvs;\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    }`,\n\n`precision mediump float;\n\n    varying vec2 vUvs;\n\n    uniform sampler2D uSampler2;\n\n    void main() {\n\n        gl_FragColor = texture2D(uSampler2, vUvs );\n    }\n\n`,\n{\n    uSampler2: PIXI.Texture.from('https://pixijs.com/assets/bg_scene_rotate.jpg'),\n});\n\nconst quad = new PIXI.Mesh(geometry3, shader);\n\nquad.position.set(400, 300);\nquad.scale.set(2);\n\napp.stage.addChild(quad);\n\napp.ticker.add((delta) =>\n{\n    quad.rotation += 0.01;\n});\n",multiPassShaderGeneratedMesh:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ height: 640, resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// Build geometry.\nconst geometry = new PIXI.Geometry()\n    .addAttribute('aVertexPosition', // the attribute name\n        [0, 0, // x, y\n            200, 0, // x, y\n            200, 200,\n            0, 200], // x, y\n        2) // the size of the attribute\n    .addAttribute('aUvs', // the attribute name\n        [0, 0, // u, v\n            1, 0, // u, v\n            1, 1,\n            0, 1], // u, v\n        2) // the size of the attribute\n    .addIndex([0, 1, 2, 0, 2, 3]);\n\n// Vertex shader. Use same shader for all passes.\nconst vertexSrc = `\n\n    precision mediump float;\n\n    attribute vec2 aVertexPosition;\n    attribute vec2 aUvs;\n\n    uniform mat3 translationMatrix;\n    uniform mat3 projectionMatrix;\n\n    varying vec2 vUvs;\n\n    void main() {\n\n        vUvs = aUvs;\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    }`;\n\n// Load a perlinnoise texture for one of the shaders.\nconst perlinTexture = PIXI.Texture.from('https://pixijs.com/assets/perlin.jpg');\n\n// First pass, generates a grid.\nconst fragmentGridSrc = `\nprecision mediump float;\nvarying vec2 vUvs;\nuniform float zoom;\n\nvoid main()\n{\n    //Generate a simple grid.\n    //Offset uv so that center is 0,0 and edges are -1,1\n    vec2 uv = (vUvs-vec2(0.5))*2.0;\n    vec2 gUv = floor(uv*zoom);\n    vec4 color1 = vec4(0.8, 0.8, 0.8, 1.0);\n    vec4 color2 = vec4(0.4, 0.4, 0.4, 1.0);\n    vec4 outColor = mod(gUv.x + gUv.y, 2.) < 0.5 ? color1 : color2;\n    gl_FragColor = outColor;\n\n}`;\n\nconst gridUniforms = {\n    zoom: 10,\n};\nconst gridShader = PIXI.Shader.from(vertexSrc, fragmentGridSrc, gridUniforms);\n// Sharing textures and meshes is possible.\n// But for simplicity each pass has its own output texture and mesh in this example.\nconst gridTexture = PIXI.RenderTexture.create({ width: 200, height: 200 });\nconst gridQuad = new PIXI.Mesh(geometry, gridShader);\nconst gridContainer = new PIXI.Container();\n\ngridContainer.addChild(gridQuad);\n\n// Second pass. Takes grid as input and makes it ripple.\nconst fragmentRippleSrc = `\nprecision mediump float;\nvarying vec2 vUvs;\nuniform float amount;\nuniform float phase;\nuniform sampler2D texIn;\n\nvoid main()\n{\n    //Generate a simple grid.\n    vec2 uv = vUvs;\n    //Calculate distance from center\n    float distance = length( uv - vec2(0.5));\n    vec4 color = texture2D(texIn, uv);\n    color.rgb *= sin(distance*25.0+phase) * amount+1.;\n    gl_FragColor = color;\n}`;\nconst rippleUniforms = {\n    amount: 0.5,\n    phase: 0,\n    texIn: gridTexture,\n};\nconst rippleShader = PIXI.Shader.from(vertexSrc, fragmentRippleSrc, rippleUniforms);\nconst rippleTexture = PIXI.RenderTexture.create({ width: 200, height: 200 });\nconst rippleQuad = new PIXI.Mesh(geometry, rippleShader);\nconst rippleContainer = new PIXI.Container();\n\nrippleContainer.addChild(rippleQuad);\n\n// Second effect. Generates a filtered noise.\nconst fragmentNoiseSrc = `\nprecision mediump float;\nvarying vec2 vUvs;\nuniform float limit;\nuniform sampler2D noise;\n\nvoid main()\n{\n    float color = texture2D(noise, vUvs).r;\n    color = step(limit, color);\n    gl_FragColor = vec4(color);\n}`;\nconst noiseUniforms = {\n    limit: 0.5,\n    noise: perlinTexture,\n};\nconst noiseShader = PIXI.Shader.from(vertexSrc, fragmentNoiseSrc, noiseUniforms);\nconst noiseTexture = PIXI.RenderTexture.create({ width: 200, height: 200 });\nconst noiseQuad = new PIXI.Mesh(geometry, noiseShader);\nconst noiseContainer = new PIXI.Container();\n\nnoiseContainer.addChild(noiseQuad);\n\n// Third effect\nconst fragmentWaveSrc = `\nprecision mediump float;\nvarying vec2 vUvs;\nuniform float amplitude;\nuniform float time;\n\nvoid main()\n{\n    //Offset uv so that center is 0,0 and edges are -1,1\n    vec2 uv = (vUvs-vec2(0.5))*2.0;\n\n    vec3 outColor = vec3(0.);\n\n    //Simple wavefunctions inversed and with small offsets.\n    outColor += 5./length(uv.y*200. - 50.0*sin( uv.x*0.25+ time*0.25)*amplitude);\n    outColor += 4./length(uv.y*300. - 100.0*sin(uv.x*0.5+time*0.5)*amplitude*1.2);\n    outColor += 3./length(uv.y*400. - 150.0*sin(uv.x*0.75+time*0.75)*amplitude*1.4);\n    outColor += 2./length(uv.y*500. - 200.0*sin(uv.x+time)*amplitude*1.6);\n\n    gl_FragColor = vec4(outColor,1.0);\n}`;\nconst waveUniforms = {\n    amplitude: 0.75,\n    time: 0,\n};\nconst waveShader = PIXI.Shader.from(vertexSrc, fragmentWaveSrc, waveUniforms);\nconst waveTexture = PIXI.RenderTexture.create({ width: 200, height: 200 });\nconst waveQuad = new PIXI.Mesh(geometry, waveShader);\nconst waveContainer = new PIXI.Container();\n\nwaveContainer.addChild(waveQuad);\n\n// Final combination pass\nconst fragmentCombineSrc = `\nprecision mediump float;\nvarying vec2 vUvs;\n\nuniform sampler2D texRipple;\nuniform sampler2D texNoise;\nuniform sampler2D texWave;\n\nvoid main()\n{\n    //Read color from all\n    vec4 ripple = texture2D(texRipple, vUvs);\n    vec4 noise = texture2D(texNoise, vUvs);\n    vec4 wave = texture2D(texWave, vUvs);\n\n    gl_FragColor = mix(ripple, wave,noise.r);\n}`;\nconst combineUniforms = {\n    texRipple: rippleTexture,\n    texNoise: noiseTexture,\n    texWave: waveTexture,\n};\nconst combineShader = PIXI.Shader.from(vertexSrc, fragmentCombineSrc, combineUniforms);\nconst combineQuad = new PIXI.Mesh(geometry, combineShader);\n\ngridContainer.position.set(10, 10);\nrippleContainer.position.set(220, 10);\nnoiseContainer.position.set(10, 220);\nwaveContainer.position.set(10, 430);\ncombineQuad.position.set(430, 220);\n\n// Add all phases to stage so all the phases can be seen separately.\napp.stage.addChild(gridContainer);\napp.stage.addChild(rippleContainer);\napp.stage.addChild(noiseContainer);\napp.stage.addChild(waveContainer);\napp.stage.addChild(combineQuad);\n\n// start the animation..\nlet time = 0;\n\napp.ticker.add((delta) =>\n{\n    time += 1 / 60;\n    // gridQuad.shader.uniforms.zoom = Math.sin(time)*5+10;\n    rippleQuad.shader.uniforms.phase = -time;\n    waveQuad.shader.uniforms.time = time;\n    noiseQuad.shader.uniforms.limit = Math.sin(time * 0.5) * 0.35 + 0.5;\n\n    // Render the passes to get textures.\n    app.renderer.render(gridQuad, { renderTexture: gridTexture });\n    app.renderer.render(rippleQuad, { renderTexture: rippleTexture });\n    app.renderer.render(noiseQuad, { renderTexture: noiseTexture });\n    app.renderer.render(waveQuad, { renderTexture: waveTexture });\n});\n",shaderToyMesh:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\n// Build geometry.\nconst geometry = new PIXI.Geometry()\n    .addAttribute('aVertexPosition', // the attribute name\n        [-100, -100, // x, y\n            100, -100, // x, y\n            100, 100,\n            -100, 100], // x, y\n        2) // the size of the attribute\n    .addAttribute('aUvs', // the attribute name\n        [0, 0, // u, v\n            1, 0, // u, v\n            1, 1,\n            0, 1], // u, v\n        2) // the size of the attribute\n    .addIndex([0, 1, 2, 0, 2, 3]);\n\nconst vertexSrc = `\n\n    precision mediump float;\n\n    attribute vec2 aVertexPosition;\n    attribute vec2 aUvs;\n\n    uniform mat3 translationMatrix;\n    uniform mat3 projectionMatrix;\n\n    varying vec2 vUvs;\n\n    void main() {\n\n        vUvs = aUvs;\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    }`;\n\nconst fragmentSrc = `\n//Based on this: https://www.shadertoy.com/view/wtlSWX\nprecision mediump float;\n\nvarying vec2 vUvs;\n\nuniform sampler2D noise;\nuniform float time;\n\n// Distance function. Just calculates the height (z) from x,y plane with really simple length check.\n// Its not exact as there could be shorter distances.\nvec2 dist(vec3 p)\n{\n    float id = floor(p.x)+floor(p.y);\n    id = mod(id, 2.);\n    float h = texture2D(noise, vec2(p.x, p.y)*0.04).r*5.1;\n    return vec2(h-p.z,id);\n}\n\n//Light calculation.\nvec3 calclight(vec3 p, vec3 rd)\n{\n    vec2 eps = vec2( 0., 0.001);\n    vec3 n = normalize( vec3(\n    dist(p+eps.yxx).x - dist(p-eps.yxx).x,\n    dist(p+eps.xyx).x - dist(p-eps.xyx).x,\n    dist(p+eps.xxy).x - dist(p-eps.xxy).x\n    ));\n\n    vec3 d = vec3( max( 0., dot( -rd ,n)));\n\n    return d;\n}\n\nvoid main()\n{\n    vec2 uv = vec2(vUvs.x,1.-vUvs.y);\n    uv *=2.;\n    uv-=1.;\n\n    vec3 cam = vec3(0.,time -2., -3.);\n    vec3 target = vec3(sin(time)*0.1, time+cos(time)+2., 0. );\n    float fov = 2.2;\n    vec3 forward = normalize( target - cam);\n    vec3 up = normalize(cross( forward, vec3(0., 1.,0.)));\n    vec3 right = normalize( cross( up, forward));\n    vec3 raydir = normalize(vec3( uv.x *up + uv.y * right + fov*forward));\n\n    //Do the raymarch\n    vec3 col = vec3(0.);\n    float t = 0.;\n    for( int i = 0; i < 100; i++)\n    {\n    vec3 p = t * raydir + cam;\n    vec2 d = dist(p);\n    t+=d.x*0.5;//Jump only half of the distance as height function used is not really the best for heightmaps.\n    if(d.x < 0.001)\n    {\n        vec3 bc = d.y < 0.5 ? vec3(1.0, .8, 0.) :\n                vec3(0.8,0.0, 1.0);\n        col = vec3( 1.) * calclight(p, raydir) * (1. - t/150.) *bc;\n        break;\n    }\n    if(t > 1000.)\n    {\n        break;\n    }\n    }\n    gl_FragColor = vec4(col, 1.);\n}`;\n\nconst uniforms = {\n    noise: PIXI.Texture.from('https://pixijs.com/assets/perlin.jpg'),\n    time: 0,\n};\n// Make sure repeat wrap is used and no mipmapping.\n\nuniforms.noise.baseTexture.wrapMode = PIXI.WRAP_MODES.REPEAT;\nuniforms.noise.baseTexture.mipmap = false;\n\n// Build the shader and the quad.\nconst shader = PIXI.Shader.from(vertexSrc, fragmentSrc, uniforms);\nconst quad = new PIXI.Mesh(geometry, shader);\n\nquad.position.set(400, 300);\nquad.scale.set(2);\n\napp.stage.addChild(quad);\n\n// start the animation..\nlet time = 0;\n\napp.ticker.add((delta) =>\n{\n    time += 1 / 60;\n    quad.shader.uniforms.time = time;\n    quad.scale.set(Number(Math.cos(time)) + 2, Number(Math.sin(time * 0.7)) + 2);\n});\n",sharedShader:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nconst geometry = new PIXI.Geometry()\n    .addAttribute('aVertexPosition', // the attribute name\n        [-100, -100, // x, y\n            100, -100, // x, y\n            100, 100]) // x, y\n\n    .addAttribute('aUvs', // the attribute name\n        [0, 0, // u, v\n            1, 0, // u, v\n            1, 1]); // u, v\n\nconst shader = PIXI.Shader.from(`\n\n    precision mediump float;\n\n    attribute vec2 aVertexPosition;\n    attribute vec2 aUvs;\n\n    uniform mat3 translationMatrix;\n    uniform mat3 projectionMatrix;\n\n    varying vec2 vUvs;\n\n    void main() {\n\n        vUvs = aUvs;\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    }`,\n\n`precision mediump float;\n\n    varying vec2 vUvs;\n\n    uniform sampler2D uSampler2;\n\n    void main() {\n\n        gl_FragColor = texture2D(uSampler2, vUvs);\n    }\n\n`,\n{\n    uSampler2: PIXI.Texture.from('https://pixijs.com/assets/bg_scene_rotate.jpg'),\n});\n\nconst shader2 = PIXI.Shader.from(`\n\n    precision mediump float;\n\n    attribute vec2 aVertexPosition;\n    attribute vec2 aUvs;\n\n    uniform mat3 translationMatrix;\n    uniform mat3 projectionMatrix;\n\n    varying vec2 vUvs;\n\n    void main() {\n\n        vUvs = aUvs;\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    }`,\n\n`precision mediump float;\n\n    varying vec2 vUvs;\n\n    uniform sampler2D uSampler2;\n\n    void main() {\n\n        gl_FragColor = texture2D(uSampler2, vUvs);\n        gl_FragColor.r += (abs(sin(gl_FragCoord.x * 0.06)) * 0.5) * 2.;\n        gl_FragColor.g += (abs(cos(gl_FragCoord.y * 0.06)) * 0.5) * 2.;\n    }\n\n`,\n{\n    uSampler2: PIXI.Texture.from('https://pixijs.com/assets/bg_scene_rotate.jpg'),\n});\n\nconst triangle = new PIXI.Mesh(geometry, shader);\n\nconst triangle2 = new PIXI.Mesh(geometry, shader2);\n\ntriangle.position.set(400, 300);\ntriangle.scale.set(2);\n\ntriangle2.position.set(500, 400);\ntriangle2.scale.set(3);\n\napp.stage.addChild(triangle2, triangle);\n\napp.ticker.add((delta) =>\n{\n    triangle.rotation += 0.01;\n    triangle2.rotation -= 0.005;\n});\n",sharingGeometry:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nconst geometry = new PIXI.Geometry()\n    .addAttribute('aVertexPosition', // the attribute name\n        [-100, -100, // x, y\n            100, -100, // x, y\n            100, 100], // x, y\n        2) // the size of the attribute\n\n    .addAttribute('aUvs', // the attribute name\n        [0, 0, // u, v\n            1, 0, // u, v\n            1, 1], // u, v\n        2); // the size of the attribute\n\nconst program = PIXI.Program.from(`\n\n    precision mediump float;\n\n    attribute vec2 aVertexPosition;\n    attribute vec2 aUvs;\n\n    uniform mat3 translationMatrix;\n    uniform mat3 projectionMatrix;\n\n    varying vec2 vUvs;\n\n    void main() {\n\n        vUvs = aUvs;\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    }`,\n\n`precision mediump float;\n\n    varying vec2 vUvs;\n\n    uniform sampler2D uSamplerTexture;\n\n    void main() {\n\n        gl_FragColor = texture2D(uSamplerTexture, vUvs);\n    }\n\n`);\n\nconst triangle = new PIXI.Mesh(geometry, new PIXI.Shader(program, {\n    uSamplerTexture: PIXI.Texture.from('https://pixijs.com/assets/bg_scene_rotate.jpg'),\n}));\n\nconst triangle2 = new PIXI.Mesh(geometry, new PIXI.Shader(program, {\n    uSamplerTexture: PIXI.Texture.from('https://pixijs.com/assets/bg_rotate.jpg'),\n}));\n\nconst triangle3 = new PIXI.Mesh(geometry, new PIXI.Shader(program, {\n    uSamplerTexture: PIXI.Texture.from('https://pixijs.com/assets/bg_displacement.jpg'),\n}));\n\ntriangle.position.set(400, 300);\ntriangle.scale.set(2);\n\ntriangle2.position.set(200, 100);\n\ntriangle3.position.set(500, 400);\ntriangle3.scale.set(3);\n\napp.stage.addChild(triangle3, triangle2, triangle);\n\napp.ticker.add((delta) =>\n{\n    triangle.rotation += 0.01;\n    triangle2.rotation -= 0.01;\n    triangle3.rotation -= 0.005;\n});\n",texturedMeshAdvanced:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nlet count = 0;\n\n// build a rope!\nconst ropeLength = 45;\n\nconst points = [];\n\nfor (let i = 0; i < 25; i++)\n{\n    points.push(new PIXI.Point(i * ropeLength, 0));\n}\n\nconst strip = new PIXI.SimpleRope(PIXI.Texture.from('https://pixijs.com/assets/snake.png'), points);\n\nstrip.x = -40;\nstrip.y = 300;\n\napp.stage.addChild(strip);\n\nconst g = new PIXI.Graphics();\n\ng.x = strip.x;\ng.y = strip.y;\napp.stage.addChild(g);\n\n// start animating\napp.ticker.add(() =>\n{\n    count += 0.1;\n\n    // make the snake\n    for (let i = 0; i < points.length; i++)\n    {\n        points[i].y = Math.sin((i * 0.5) + count) * 30;\n        points[i].x = i * ropeLength + Math.cos((i * 0.3) + count) * 20;\n    }\n    renderPoints();\n});\n\nfunction renderPoints()\n{\n    g.clear();\n\n    g.lineStyle(2, 0xffc2c2);\n    g.moveTo(points[0].x, points[0].y);\n\n    for (let i = 1; i < points.length; i++)\n    {\n        g.lineTo(points[i].x, points[i].y);\n    }\n\n    for (let i = 1; i < points.length; i++)\n    {\n        g.beginFill(0xff0022);\n        g.drawCircle(points[i].x, points[i].y, 10);\n        g.endFill();\n    }\n}\n",texturedMeshBasic:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nlet count = 0;\n\n// build a rope!\nconst ropeLength = 918 / 20;\n\nconst points = [];\n\nfor (let i = 0; i < 20; i++)\n{\n    points.push(new PIXI.Point(i * ropeLength, 0));\n}\n\nconst strip = new PIXI.SimpleRope(PIXI.Texture.from('https://pixijs.com/assets/snake.png'), points);\n\nstrip.x = -459;\n\nconst snakeContainer = new PIXI.Container();\n\nsnakeContainer.x = 400;\nsnakeContainer.y = 300;\n\nsnakeContainer.scale.set(800 / 1100);\napp.stage.addChild(snakeContainer);\n\nsnakeContainer.addChild(strip);\n\napp.ticker.add(() =>\n{\n    count += 0.1;\n\n    // make the snake\n    for (let i = 0; i < points.length; i++)\n    {\n        points[i].y = Math.sin((i * 0.5) + count) * 30;\n        points[i].x = i * ropeLength + Math.cos((i * 0.3) + count) * 20;\n    }\n});\n",triangleColor:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nconst geometry = new PIXI.Geometry()\n    .addAttribute('aVertexPosition', // the attribute name\n        [-100, -50, // x, y\n            100, -50, // x, y\n            0.0, 100.0], // x, y\n        2) // the size of the attribute\n\n    .addAttribute('aColor', // the attribute name\n        [1, 0, 0, // r, g, b\n            0, 1, 0, // r, g, b\n            0, 0, 1], // r, g, b\n        3); // the size of the attribute\n\nconst shader = PIXI.Shader.from(`\n\n    precision mediump float;\n    attribute vec2 aVertexPosition;\n    attribute vec3 aColor;\n\n    uniform mat3 translationMatrix;\n    uniform mat3 projectionMatrix;\n\n    varying vec3 vColor;\n\n    void main() {\n\n        vColor = aColor;\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    }`,\n\n`precision mediump float;\n\n    varying vec3 vColor;\n\n    void main() {\n        gl_FragColor = vec4(vColor, 1.0);\n    }\n\n`);\n\nconst triangle = new PIXI.Mesh(geometry, shader);\n\ntriangle.position.set(400, 300);\ntriangle.scale.set(2);\n\napp.stage.addChild(triangle);\n\napp.ticker.add((delta) =>\n{\n    triangle.rotation += 0.01;\n});\n",triangleTextured:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nconst geometry = new PIXI.Geometry()\n    .addAttribute('aVertexPosition', // the attribute name\n        [-100, -100, // x, y\n            100, -100, // x, y\n            100, 100], // x, y\n        2) // the size of the attribute\n\n    .addAttribute('aColor', // the attribute name\n        [1, 0, 0, // r, g, b\n            0, 1, 0, // r, g, b\n            0, 0, 1], // r, g, b\n        3) // the size of the attribute\n\n    .addAttribute('aUvs', // the attribute name\n        [0, 0, // u, v\n            1, 0, // u, v\n            1, 1], // u, v\n        2); // the size of the attribute\n\nconst vertexSrc = `\n\n    precision mediump float;\n\n    attribute vec2 aVertexPosition;\n    attribute vec3 aColor;\n    attribute vec2 aUvs;\n\n    uniform mat3 translationMatrix;\n    uniform mat3 projectionMatrix;\n\n    varying vec2 vUvs;\n    varying vec3 vColor;\n\n    void main() {\n\n        vUvs = aUvs;\n        vColor = aColor;\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    }`;\n\nconst fragmentSrc = `\n\n    precision mediump float;\n\n    varying vec3 vColor;\n    varying vec2 vUvs;\n\n    uniform sampler2D uSampler2;\n\n    void main() {\n\n        gl_FragColor = texture2D(uSampler2, vUvs) * vec4(vColor, 1.0);\n    }`;\n\nconst uniforms = { uSampler2: PIXI.Texture.from('https://pixijs.com/assets/bg_scene_rotate.jpg') };\n\nconst shader = PIXI.Shader.from(vertexSrc, fragmentSrc, uniforms);\n\nconst triangle = new PIXI.Mesh(geometry, shader);\n\ntriangle.position.set(400, 300);\ntriangle.scale.set(2);\n\napp.stage.addChild(triangle);\n\napp.ticker.add((delta) =>\n{\n    triangle.rotation += 0.01;\n});\n",triangle:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nconst geometry = new PIXI.Geometry()\n    .addAttribute('aVertexPosition', [-100, -50, 100, -50, 0, 100]);\n\nconst shader = PIXI.Shader.from(`\n\n    precision mediump float;\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 translationMatrix;\n    uniform mat3 projectionMatrix;\n\n    void main() {\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    }`,\n\n`precision mediump float;\n\n    void main() {\n        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n\n`);\n\nconst triangle = new PIXI.Mesh(geometry, shader);\n\ntriangle.position.set(400, 300);\n\napp.stage.addChild(triangle);\n\napp.ticker.add((delta) =>\n{\n    triangle.rotation += 0.01;\n});\n",uniforms:"import * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application({ resizeTo: window });\n\ndocument.body.appendChild(app.view);\n\nconst geometry = new PIXI.Geometry()\n    .addAttribute('aVertexPosition', // the attribute name\n        [-100, -100, // x, y\n            100, -100, // x, y\n            100, 100,\n            -100, 100], // x, y\n        2) // the size of the attribute\n    .addAttribute('aUvs', // the attribute name\n        [0, 0, // u, v\n            1, 0, // u, v\n            1, 1,\n            0, 1], // u, v\n        2) // the size of the attribute\n    .addIndex([0, 1, 2, 0, 2, 3]);\n\nconst vertexSrc = `\n\n    precision mediump float;\n\n    attribute vec2 aVertexPosition;\n    attribute vec2 aUvs;\n\n    uniform mat3 translationMatrix;\n    uniform mat3 projectionMatrix;\n\n    varying vec2 vUvs;\n\n    void main() {\n\n        vUvs = aUvs;\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    }`;\n\nconst fragmentSrc = `\n\n    precision mediump float;\n\n    varying vec2 vUvs;\n\n    uniform sampler2D uSampler2;\n    uniform float time;\n\n    void main() {\n\n        gl_FragColor = texture2D(uSampler2, vUvs + sin( (time + (vUvs.x) * 14.) ) * 0.1 );\n    }`;\n\nconst uniforms = {\n    uSampler2: PIXI.Texture.from('https://pixijs.com/assets/bg_scene_rotate.jpg'),\n    time: 0,\n};\n\nconst shader = PIXI.Shader.from(vertexSrc, fragmentSrc, uniforms);\n\nconst quad = new PIXI.Mesh(geometry, shader);\n\nquad.position.set(400, 300);\nquad.scale.set(2);\n\napp.stage.addChild(quad);\n\n// start the animation..\n// requestAnimationFrame(animate);\n\napp.ticker.add((delta) =>\n{\n    quad.rotation += 0.01;\n    quad.shader.uniforms.time += 0.1;\n});\n"}},x=n=>{const e={hide:!1,usesWebWorkerLibrary:!1};return"string"==typeof n?{...e,name:n}:{...e,...n}},f=Object.entries(m).reduce(((n,e)=>{let[t,i]=e;return{...n,[t]:i.reduce(((n,e)=>{const i=x(e),{name:a,hide:o,usesWebWorkerLibrary:r}=i;return{...n,[a]:{source:g[t][a],hide:o,usesWebWorkerLibrary:r}}}),{})}}),{});function b(n){const e=n.replace(/([A-Z])/g," $1");return e.charAt(0).toUpperCase()+e.slice(1)}const w=Object.entries(m).map((n=>{let[e,t]=n;const i=t.reduce(((n,t)=>{const{name:i,hide:a}=x(t);return a?n:n.concat({value:`${e}.${i}`,label:b(i)})}),[]);return{label:b(e),options:i}})),I=n=>{let{urlSourceCode:e,selectedOptionId:t,setURLState:i}=n;const a=Boolean(e),r=(0,o.useMemo)((()=>function(n){const[e,t]=n.split(".");return f[e]?.[t]}(t)),[t]),{source:s,usesWebWorkerLibrary:d}=(0,o.useMemo)((()=>e?{source:e,usesWebWorkerLibrary:!1}:r),[e,r]),p=(0,o.useMemo)((()=>a?w.concat({label:"Custom Code",options:[{label:"User Edited Code",value:"custom"}]}):w),[a]),c=(0,o.useCallback)((n=>{n!==t&&i({source:void 0,exampleId:n},!0,!0)}),[t,i]),l=(0,o.useCallback)((n=>{s!==n&&i({source:n,exampleId:"custom"},!a)}),[a,i,s]);return{sourceCode:s,usesWebWorkerLibrary:d,exampleOptions:p,handleOptionSelected:c,handleEditorCodeChanged:l}};var v=t(2215),y=t(2124),P=t(6550);function S(n,e,t){const i=(0,P.k6)(),a=(0,o.useMemo)((()=>t(function(n){const e=new URLSearchParams(n);return Array.from(e.entries()).reduce(((n,e)=>{let[t,i]=e;return{...n,[t]:i}}),{})}(i.location.search))),[t,i.location.search]),r=(0,o.useRef)("function"==typeof n?n(a):n),s=(0,o.useMemo)((()=>({...r.current,...a})),[a]);return[s,function(n,t,a){void 0===t&&(t=!0),void 0===a&&(a=!1);const o="function"==typeof n?n(s):{...s,...n},d=Object.entries(o).reduce(((n,e)=>{let[t,i]=e;return i===r.current[t]?n:{...n,[t]:i}}),{}),p=new URLSearchParams(Object.entries(e(d))),c={pathname:location.pathname,search:p.toString()};a?t?i.push(c):i.replace(c):t?history.pushState(c,"",`${c.pathname}?${p.toString()}`):history.replaceState(c,"",`${c.pathname}?${p.toString()}`)}]}const C=(0,y.qhW)(y.kKJ,(function(n){const e=JSON.stringify({code:n});return btoa(e)})),T=(0,y.qhW)(y.kKJ,(function(n){try{return JSON.parse(atob(n)).code}catch{return}})),X=(0,y.rO9)({source:C}),k=(0,y.rO9)({source:T}),M={pageWrapper:"pageWrapper_KYDs",playgroundWrapper:"playgroundWrapper_jdw_",nav:"nav_P7VN",select:"select_WD2B"};var j=t(1262);function F(){const[n,e]=(n=>{let{defaultExampleId:e,defaultPixiVersion:t}=n;return S((n=>{const{source:i,exampleId:a,pixiVersion:o}=n;return{source:i??void 0,exampleId:i?"custom":a??e,pixiVersion:o??t}}),X,k)})({defaultExampleId:"sprite.basic",defaultPixiVersion:v.$}),{source:t,exampleId:o,pixiVersion:r}=n,{sourceCode:s,usesWebWorkerLibrary:d,exampleOptions:p,handleOptionSelected:c,handleEditorCodeChanged:h}=I({urlSourceCode:t,selectedOptionId:o,setURLState:e}),{selectedVersion:m,handleVersionChanged:g,versionOptions:x}=(0,v._)({selectedVersionId:r,setURLState:e}),{npm:f,dev:b=!1}=m;return(0,l.jsx)(i.Z,{title:"Playground",noFooter:!0,wrapperClassName:M.wrapper,children:(0,l.jsx)(j.Z,{children:()=>(0,l.jsxs)("div",{className:M.playgroundWrapper,children:[(0,l.jsxs)("div",{className:M.nav,children:[(0,l.jsx)(u,{label:"Example:",labelClassName:M.select,selectedId:o,options:p,onValueChange:c}),(0,l.jsx)(u,{label:"Version:",labelClassName:M.select,selectedId:r,options:x,onValueChange:g})]}),(0,l.jsx)(a.Z,{code:s,pixiVersion:f,isPixiDevVersion:b,isPixiWebWorkerVersion:d,onCodeChanged:h,mode:"fullscreen"})]})})})}},1825:n=>{n.exports=JSON.parse('[{"versionLabel":"dev","version":"dev","releaseNotes":"https://github.com/pixijs/pixijs/releases","build":"https://pixijs.download/dev/pixi.min.js","docs":"https://pixijs.download/release/docs","dev":true,"npm":"https://pkg.csb.dev/pixijs/pixijs/commit/a0204d43"},{"versionLabel":"v7.3.x","version":"7.3.1","releaseNotes":"https://github.com/pixijs/pixijs/releases/tag/v7.3.1","build":"https://pixijs.download/v7.3.1/pixi.min.js","docs":"https://pixijs.download/v7.3.1/docs/index.html","npm":"7.3.1","latest":true},{"versionLabel":"v7.2.x","version":"7.2.4","releaseNotes":"https://github.com/pixijs/pixijs/releases/tag/v7.2.4","build":"https://pixijs.download/v7.2.4/pixi.min.js","docs":"https://pixijs.download/v7.2.4/docs/index.html","npm":"7.2.4"},{"versionLabel":"v7.1.x","version":"7.1.4","releaseNotes":"https://github.com/pixijs/pixijs/releases/tag/v7.1.4","build":"https://pixijs.download/v7.1.4/pixi.min.js","docs":"https://pixijs.download/v7.1.4/docs/index.html","npm":"7.1.4"},{"versionLabel":"v7.0.x","version":"7.0.5","releaseNotes":"https://github.com/pixijs/pixijs/releases/tag/v7.0.5","build":"https://pixijs.download/v7.0.5/pixi.min.js","docs":"https://pixijs.download/v7.0.5/docs/index.html","npm":"7.0.5"},{"versionLabel":"v6.x","version":"6.5.10","releaseNotes":"https://github.com/pixijs/pixijs/releases/tag/v6.5.10","build":"https://pixijs.download/v6.5.10/pixi.min.js","docs":"https://pixijs.download/v6.5.10/docs/index.html","npm":"6.5.10"},{"versionLabel":"v5.x","version":"5.3.12","releaseNotes":"https://github.com/pixijs/pixijs/releases/tag/v5.3.12","build":"https://pixijs.download/v5.3.12/pixi.min.js","docs":"https://pixijs.download/v5.3.12/docs/index.html","npm":"5.3.12"},{"versionLabel":"v4.x","version":"4.8.9","releaseNotes":"https://github.com/pixijs/pixijs/releases/tag/v4.8.9","build":"https://pixijs.download/v4.8.9/pixi.min.js","docs":"https://pixijs.download/v4.8.9/docs/index.html","npm":"4.8.9"}]')}}]);